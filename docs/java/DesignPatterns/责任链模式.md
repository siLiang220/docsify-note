**责任链模式：责任链模式是一种对象的行为模型。责任链模式里，很多对象由每一个对象对其下家的引用而连接形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此对象的请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。**

责任链的优点：
-   单一职责：⼀个类和⽅法只做⼀件事 。降低了耦合度，调用方不需要知道请求由哪些 handler 处理，而 handler 也不需要知道互相之间的传递关系，由系统组织和分配。
-   开闭原则：一个软件实体（如类、模块和函数）应该对扩展开放，对修改关闭。带来良好的扩展性，使得增加处理者的实现很简单，可以在链路中任意位置插入新的 handler。

责任链的缺点：

-   链路长：请求从链头发出，直到被中断或者结束，可能会影响系统性能。
-   排查较慢：一般是不太能一目了然的看到是哪个节点出现了问题，需要多添加一些核心日志。

## 实战应用

在正常的责任链设计模式中，每个处理者与下一个处理者的关系是固定的，没有办法根据参数动态组装

- 通过建造者模式构建动态的链路类型
```java
private int getChainType(String params1, String params2){  
    //拼接参数获取对应的场景  
    String mapKey =params1+"_"+ params2;  
    return BuildChainConstant.CHAIN_MAP.getOrDefault(mapKey,1);  
}  
  
//根据类型查找对应的链路  
public List<ValuationResponsibilityChainHandle> buildChain(Integer type){  
    List<ValuationResponsibilityChainHandle> chainHandles = Lists.newArrayList();  
  
    switch (type){  
        case 1:  
            buildSceneA(chainHandles);  
            break;  
        default:  
            break;  
  
    }  
    return chainHandles;  
}  
//构建场景a  
public void buildSceneA(List<ValuationResponsibilityChainHandle> chainHandles){  
    chainHandles.add(new EnvironmentalRecycleHandler());  
    chainHandles.add(new BackListHandle());  
    chainHandles.add(new OtherFunctionHandler());  
}
```


- 抽象的处理者 通过`skipNode` 判断是否执行该方法
```java
public interface ValuationResponsibilityChainHandle {  

    /**  
     * 处理  
     * @param context  
     * @param request  
     * @param response  
     */  
    void handle(ValuationContext context, ChainResponsibilityRequest request, ChainResponsibilityResponse response);  
  
    /**  
     * 是否执行该节点逻辑  
     * @param context  
     * @param request  
     * @param response  
     * @return  
     */    boolean skipNode(ValuationContext context, ChainResponsibilityRequest request, ChainResponsibilityResponse response);  
}
```

**控制流程的中断**：处理者可以通过当前的上下文或其他参数判断是否需要执行
- 处理者处理
```java
public class BackListHandle implements ValuationResponsibilityChainHandle{  
    @Override  
    public void handle(ValuationContext context, ChainResponsibilityRequest request, ChainResponsibilityResponse response) {  
        if (ObjectUtil.isEmpty("user")){  
            return;  
        }  
        //判断黑名单规则  
        context.setSkipNote(true);  
    }  
    //判断校验的规则 是否执行该节点  
    @Override  
    public boolean skipNode(ValuationContext context, ChainResponsibilityRequest request, ChainResponsibilityResponse response) {  
         return Boolean.TRUE.equals(context.getSkipNote()) && (11 == 22);  
    }  
}
```

- 遍历责任链
```java
//遍历责任链  
protected  void handle(ValuationContext context, ChainResponsibilityRequest request, ChainResponsibilityResponse response,List<ValuationResponsibilityChainHandle> handlerList){  
    if (!CollectionUtils.isEmpty(handlerList)){  
        for (ValuationResponsibilityChainHandle handle : handlerList){  
            if (handle.skipNode(context,request,response)){  
                continue;  
            }  
            handle.handle(context,request,response);  
        }  
    }  
}
```

- 获取最后的结果
```java
public void getPrice(){  
    int chainType = getChainType("recovery", "estimate");  
    List<ValuationResponsibilityChainHandle> chainHandles = buildChain(chainType);  
    ValuationContext valuationContext = new ValuationContext();  
    valuationContext.setSkipNote(true);  
    handle(valuationContext,new ChainResponsibilityRequest(),new ChainResponsibilityResponse(),chainHandles);  
}
```

## 参考文章
[转转技术-责任链在转转精准估价中的应用](https://zhuanlan.zhihu.com/p/546668762)