**状态模式**：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。状态模式包含以下主要角色：

- 环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。
- 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。
- 具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。

状态枚举类
```java
@Getter
@AllArgsConstructor
public enum OrderStateEnum {
    WAIT_PAY(0, "待支付"),
    WAIT_DELIVER(1, "待发货"),
    WAIT_RECEIVE(2, "待收货"),
    REFUNDING(3, "退款中"),

    FINISH(10, "已完成"),
    REFUNDED(11, "已退款"),
    ;

    private Integer code;
    private String desc;

    public static OrderStateEnum getEnumByCode(Integer code) {
        for (OrderStateEnum stateEnum : values()) {
            if (stateEnum.getCode().equals(code)) {
                return stateEnum;
            }
        }
        throw new RuntimeException("code非法");
    }
}

```

状态上下文类
```java
public class OrderStateContext {

    private AbstractOrderState orderState;

    public OrderStateContext() {}

    public AbstractOrderState getOrderState() {
        return orderState;
    }

    public void setOrderState(AbstractOrderState orderState) {
        this.orderState = orderState;
    }

    /**
     * 发起支付
     *
     * @param order
     */
    void pay(Order order) {
        orderState.pay(this, order);
    }

    /**
     * 订单发货
     *
     * @param order
     */
    void deliver(Order order) {
        orderState.deliver(this, order);
    }

    /**
     * 订单收货
     *
     * @param order
     */
    void receive(Order order) {
        orderState.receive(this, order);
    }

    /**
     * 申请售后
     *
     * @param order
     */
    void applyRefund(Order order) {
        orderState.applyRefund(this, order);
    }

    /**
     * 退款完成
     *
     * @param order
     */
    void finishRefund(Order order) {
        orderState.finishRefund(this, order);
    }
}

```
抽象的状态类
```java
public abstract class AbstractOrderState {

    public abstract Enum type();

    /**
     * 发起支付
     *
     * @param context
     * @param order
     */
    public void pay(OrderStateContext context, Order order) {
        throw new RuntimeException("该状态下不支持该操作");
    }

    /**
     * 订单发货
     *
     * @param context
     * @param order
     */
    public void deliver(OrderStateContext context, Order order) {
        throw new RuntimeException("该状态下不支持该操作");
    }

    /**
     * 订单收货
     *
     * @param context
     * @param order
     */
    public void receive(OrderStateContext context, Order order) {
        throw new RuntimeException("该状态下不支持该操作");
    }

    /**
     * 售后申请
     *
     * @param context
     * @param order
     */
    public void applyRefund(OrderStateContext context, Order order) {
        throw new RuntimeException("该状态下不支持该操作");
    }

    /**
     * 退款完成
     *
     * @param context
     * @param order
     */
    public void finishRefund(OrderStateContext context, Order order) {
        throw new RuntimeException("该状态下不支持该操作");
    }
}

```

具体的状态类
```java
@Component
public class WaitDeliverOrderState extends AbstractOrderState {

    @Autowired
    private OrderRepository orderRepository;

    @Override
    public Enum type() {
        return OrderStateEnum.WAIT_DELIVER;
    }

    /**
     * 发货
     * @param context
     * @param order
     */
    public void deliver(OrderStateContext context, Order order) {
        OrderStateEnum newState = OrderStateEnum.WAIT_RECEIVE;
        //操作发货，并更新数据库
        order.setStatus(newState.getCode());
        orderRepository.update(order);
        //更新上下文状态
        context.setOrderState(OrderStateFactory.getState(newState));
        System.out.println("订单号："+ order.getOrderSn() + " 发货成功！状态流转至：" + newState.getDesc());
    }

    /**
     * 申请售后
     * @param context
     * @param order
     */
    public void applyRefund(OrderStateContext context, Order order) {
        OrderStateEnum newState = OrderStateEnum.REFUNDING;
        //操作发货，并更新数据库
        order.setStatus(newState.getCode());
        orderRepository.update(order);
        //更新上下文状态
        context.setOrderState(OrderStateFactory.getState(newState));
        System.out.println("订单号："+ order.getOrderSn() + " 申请售后！状态流转至：" + newState.getDesc());
    }
}


```
封装状态实例类
```java
@Component
public class OrderStateFactory implements ApplicationContextAware {

    private static final Map<Enum, AbstractOrderState> stateMap = new HashMap<>(OrderStateEnum.values().length);

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        Map<String, AbstractOrderState> beans = applicationContext.getBeansOfType(AbstractOrderState.class);
        beans.values().forEach(item -> stateMap.put(item.type(), item));
    }

    public static AbstractOrderState getState(Enum orderStateEnum) {
        return stateMap.get(orderStateEnum);
    }
}

```
代码测试
```java
@Service
public class OrderService {

    @Autowired
    private OrderRepository orderRepository;

    /**
     * 创建订单，和之前一样
     */
    public String create(Long buyerId, Long skuId) {
        Order order = new Order();
        order.setOrderSn(generateOrderSn());
        order.setBuyerId(buyerId);
        order.setSkuId(skuId);
        order.setStatus(OrderStateEnum.WAIT_PAY.getCode());
        orderRepository.insert(order);
        return order.getOrderSn();
    }

    /**
     * 发起支付
     *
     * @param orderSn
     */
    public void pay(String orderSn) {
        Order order = orderRepository.get(orderSn);
        OrderStateContext context = new OrderStateContext();
        AbstractOrderState currentState = OrderStateFactory.getState(OrderStateEnum.getEnumByCode(order.getStatus()));
        context.setOrderState(currentState);
        context.pay(order);
    }

    /**
     * 订单发货
     *
     * @param orderSn
     */
    public void deliver(String orderSn) {
        Order order = orderRepository.get(orderSn);
        OrderStateContext context = new OrderStateContext();
        AbstractOrderState currentState = 		OrderStateFactory.getState(OrderStateEnum.getEnumByCode(order.getStatus()));
        context.setOrderState(currentState);
        context.deliver(order);
    }

    /**
     * 订单收货
     * 申请售后
     * 退款完成 
     * 与上述代码基本一致，
     */
    
     /**
     * 售后申请
     * @param orderSn
     */
    void refund(String orderSn) {
        Order order = orderRepository.get(orderSn);
        //判断是否是待收货状态
        if (!Objects.equals(order.getStatus(), OrderStateEnum.WAIT_DELIVER.getCode())
          && !Objects.equals(order.getStatus(), OrderStateEnum.WAIT_RECEIVE.getCode())) {
            throw new RuntimeException("该状态下不支持该操作");
        }
        OrderStateEnum newState = OrderStateEnum.REFUNDING;
        //操作收货，并更新数据库
        order.setStatus(newState.getCode());
        orderRepository.update(order);
    }

}

```
模拟外部操作
```java
@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class })
public class StateClientTest {

    public static void main(String[] args) {
        SpringApplication.run(StateClientTest.class, args);
        OrderService orderService = SpringContextUtil.getBean(OrderService.class);

        //1.创建一笔订单
        String orderSn = orderService.create(1L, 1L);

        //2.执行支付操作
        orderService.pay(orderSn);

        //3.执行发货操作
        orderService.deliver(orderSn);

        //4.执行收货操作
        orderService.receive(orderSn);

        //5.尝试执行下支付操作，会失败
        orderService.pay(orderSn);
    }
}


```
