
##  概况MQTT连接

### MQTT over TCP
`TCP/IP` 应用广泛，是一种面向连接的、可靠的、基于字节流的传输层通信协议。它通过`ACK`确认和重传机制，能够保证发送的所有字节在接收时是完全一样的，并且字节顺序也是正确的。`MQTT` 通常基于 `TCP` 进行网络通信，它继承了 TCP `的很多优点`，能稳定运行在低带宽、高延时、及资源受限的环境下。

### MQTT over WebSocket

https://www.emqx.com/zh/blog/connect-to-mqtt-broker-with-websocket


### MQTT 连接参数的使用

### 连接地址
- `MQTT` 的连接地址通常包含 ：服务器 IP 或者域名、服务器端口、连接协议。
### 基于 TCP 的 MQTT 连接

- `mqtt` 是普通的 `TCP` 连接，端口一般为 1883。 
- `mqtts` 是基于 `TLS/SSL `的安全连接，端口一般为 8883。
- 比如 mqtt://broker.emqx.io:1883 是一个基于普通 `TCP` 的 `MQTT` 连接地址。

### 基于 WebSocket 的连接

- `ws` 是普通的 `WebSocket` 连接，端口一般为 8083。
- `wss` 是基于 `WebSocket` 的安全连接，端口一般为 8084。 

当使用 `WebSocket` 连接时，连接地址还需要包含 Path，`EMQX` 默认配置的Path 是/mqtt。比如ws://broker.emqx.io:8083/mqtt 是一个基于 `WebSocket` 的 `MQTT` 连接地址。


### 客户端 ID（Client ID）
MQTT 服务器使用 Client ID 识别客户端，连接到服务器的每个客户端都必须要有唯一的Client ID。ClientID 的长度通常为 1 至 23 个字节的 UTF-8 字符串。
> [!Warning] 如果客户端使用一个重复的 Client ID 连接至服务器，将会把已使用该 Client ID 连接成功的客户端踢下线。

### 用户名与密码（Username & Password）

`MQTT` 协议可以通过用户名和密码来进行相关的认证和授权，但是如果此信息未加密，则用户名和密码将以明文方式传输。如果设置了用户名与密码认证，那么最好要使用 `mqtts` 或`wss` 协议。大多数 `MQTT` 服务器默认为匿名认证，匿名认证时用户名与密码设置为空字符串即可。

### 连接超时（Connect Timeout）

连接超时时长，收到服务器连接确认前的等待时间，等待时间内未收到连接确认则为连接失败。

### 保活周期（Keep Alive）
- 保活周期，是一个以秒为单位的时间间隔。客户端在无报文发送时，将按 `Keep Alive` 设定的值定时向服务端发送心跳报文，确保连接不被服务端断开。
- 在连接建立成功后，如果服务器没有在 Keep Alive 的 1.5 倍时间内收到来自客户端的任何包，则会认为和客户端之间的连接出现了问题，此时服务器便会断开和客户端的连接。

### 清除会话（Clean Session）
- 为 false 时表示创建一个 **持久会话**，在客户端断开连接时，会话仍然保持并保存离线消息，直到会话超时注销。为 true 时表示创建一个新的临时会话，在客户端断开时，会话自动销毁。持久会话避免了客户端掉线重连后消息的丢失，并且免去了客户端连接后重复的订阅开销。这一功能在带宽小，网络不稳定的物联网场景中非常实用。

> [!Warning] 持久会话恢复的前提是客户端使用固定的 Client ID 再次连接，如果Client ID是动态的，那么连接成功后将会创建一个新的持久会话。

### 遗嘱消息（Last Will）

遗嘱消息是 `MQTT` 为那些可能出现意外断线的设备提供的将遗嘱优雅地发送给其他客户端的能力。设置了遗嘱消息消息的 `MQTT` 客户端异常下线时，`MQTT` 服务器会发布该客户端设置的遗嘱消息。

> 意外断线包括：因网络故障，连接被服务端关闭；设备意外掉电；设备尝试进行不被允许的操作而被服务端关闭连接等。

- 当设备意外断线时，遗嘱消息将被发送至遗嘱 Topic； 
- 遗嘱 `Payload` 是待发送的消息内容； 
- 遗嘱 `QoS` 与普通 `MQTT` 消息的 `QoS` 一致 
- 遗嘱 Retain 为 true 时表明遗嘱消息是保留消息。`MQTT` 服务器会为每个主题存储最新一条保留消息，以方便消息发布后才上线的客户端在订阅主题时仍可以接收到该消息

### MQTT 5.0 新增连接参数

#### Clean Start & Session Expiry Interval

MQTT 5.0 中将 Clean Session 拆分成了 Clean Start 与 Session Expiry Interval。Clean Start 用于指定连接时是创建一个全新的会话还是尝试复用一个已存在的会话。为true 时表示必须丢弃任何已存在的会话，并创建一个全新的会话；为 false 时表示必须使用与Client ID 关联的会话来恢复与客户端的通信（除非会话不存在）。 Session Expiry Interval 用于指定网络连接断开后会话的过期时间。设置为0 或未设置，表示断开连接时会话即到期；设置为大于 0 的数值，则表示会话在网络连接关闭后会保持多少秒；设置为0xFFFFFFFF表示会话永远不会过期。

##  一、Payload Format Indicator 和 Content Type

###  什么是 Payload Format Indicator?

Payload Format Indicator 是 MQTT 5.0 引入的一个全新属性，用来指示 [MQTT 报文](https://www.emqx.com/zh/blog/introduction-to-mqtt-control-packets)中有效载荷的格式。但 CONNECT、SUBSCRIBE 与 UNSUBSCRIBE 报文中有效载荷的格式都是固定不变的，所以实际上只有 PUBLISH 报文和 CONNECT 报文中的遗嘱消息需要声明其有效载荷的格式。

**如果 Payload Format Indicator 的值为 0 或者没有指定这个属性，表示当前有效载荷是未指定的字节流；而如果这个属性的值为 1，则表示当前有效载荷是 UTF-8 编码的字符数据**。

这允许接收者在无需解析具体内容的前提下检查有效载荷的格式，例如服务端可以检查有效载荷是否是一个有效的 UTF-8 字符串，避免将格式不正确的应用消息分发给订阅者。不过考虑到这个操作对服务端带来的负担和实际能够取得的收益，这通常是一个可选的行为。

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20240425132036.png)

### 什么是 Content Type?

Content Type 也是 MQTT 5.0 引入的一个全新属性，与 Payload Format Indicator 类似，它同样仅存在于 PUBLISH 报文和 CONNECT 报文的遗嘱消息中。

**Content Type 的值是一个 UTF-8 编码的字符串**，用来描述应用消息的内容，这可以帮助接收端了解如何解析应用消息的有效载荷。例如，消息的内容是一个 JSON 对象，那么 Content Type 可以被设置为 "json"。

这个字符串的具体内容完全由发送端和接收端决定，在消息的整个传输过程中，服务端不会使用这个属性来验证消息内容的格式是否正确，它只负责将这个属性原封不动地转发给订阅者。

所以只要接收端能够理解，你甚至可以用 “cocktail” 来描述 JSON 类型。但为了避免造成不必要的困扰，通常我们更推荐使用已知的 MIME 类型来描述消息内容，例如 `application/json`、`application/xml` 等等。

Content Type 在需要支持多种数据类型的场景中非常有用。比如当我们在聊天软件中向对方发送图片，图片可能有 png，gif，jpeg 等多种格式，如何向对端指示我们发送的二进制数据所对应的图片格式？

在 5.0 之前，我们可能会选择在主题中包含图片格式，比如 `to/userA/image/png`。但显然，随着支持的图片格式的增加，系统中的主题也会泛滥成灾。而在 5.0 中，我们只需要将 Content Type 属性设置为 `image/png` 即可。

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20240425132210.png)
### Payload Format Indicator 与 Content Type 必须一起使用吗？
Payload Format Indicator 和 Content Type 是否需要同时使用，主要取决于我们的应用场景。

对于订阅端来说，他可以根据 Content Type 属性的值来判断消息的内容应该是 UTF-8 字符串还是二进制数据，所以 Payload Format Indicator 属性的意义不大。

不过对于服务端来说，他并不了解 Content Type 的值的含义，所以如果我们希望服务端检查消息的有效载荷是否符合 UTF-8 编码规范，就必须借助 Payload Format Indicator 属性。


## 二、MQTT 保留消息

### 什么是 MQTT 保留消息？

保留消息用于确保新订阅Topic的设备能及时收到最新状态的消息，即使消息在设备订阅之前发布。服务端向Topic发布消息时，如果消息携带保留标记（Reatin），物联网平台将会保存这个消息并实时发布给订阅者，后续订阅该Topic的设备都会收到**保留消息**。保留消息在MQTT 3.1.1标准中就已定义，阿里云物联网平台在MQTT 5.0接入时支持这个特性。本文为您介绍保留消息的概念、交互过程和使用场景。

发布者发布消息时，如果 Retained 标记被设置为 true，则该消息即是 MQTT 中的保留消息（Retained Message）。MQTT 服务器会为每个主题存储最新一条保留消息，以方便消息发布后才上线的客户端在订阅主题时仍可以接收到该消息。

如下图，当客户端订阅主题时，如果服务端存在该主题匹配的保留消息，则该保留消息将被立即发送给该客户端。

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20240425133318.png)
### 何时使用 MQTT 保留消息？

发布订阅模式虽然能让消息的发布者与订阅者充分解耦，但也存在一个缺点，即订阅者无法主动向发布者请求消息。订阅者何时收到消息完全依赖于发布者何时发布消息，这在某些场景中就产生了不便。

借助保留消息，新的订阅者能够立即获取最近的状态，而不需要等待无法预期的时间，例如：

- 智能家居设备的状态只有在变更时才会上报，但是控制端需要在上线后就能获取到设备的状态；
- 传感器上报数据的间隔太长，但是订阅者需要在订阅后立即获取到最新的数据；
- 传感器的版本号、序列号等不会经常变更的属性，可在上线后发布一条保留消息告知后续的所有订阅者。

### 关于 MQTT 保留消息的 Q&A

#### 如何判断一条消息是否是保留消息？
当客户端订阅了有保留消息的主题后，即会收到该主题的保留消息，可通过消息中的保留标志位判断是否是保留消息。需要注意的是，在保留消息发布前订阅主题，将不会收到保留消息。**需要待保留消息发布后，重新订阅该主题，才会收到保留消息。**

如下图，我们先订阅主题 `sensor/t2`，然后向该主题发布一条保留消息，该订阅会立即收到一条消息，但是该消息并不是保留消息。当我们删除该订阅，再次重新订阅 `sensor/t2` 主题时，立即收到了刚刚发布的保留消息。

#### 保留消息将保存多久？如何删除？
服务器只会为每个主题保存最新一条保留消息，保留消息的保存时间与服务器的设置有关。若服务器设置保留消息存储在内存，则 MQTT 服务器重启后消息即会丢失；若存储在磁盘，则服务器重启后保留消息仍然存在。

保留消息虽然存储在服务端中，但它并不属于会话的一部分。也就是说，即便发布这个保留消息的会话已结束，保留消息也不会被删除。删除保留消息有以下几种方式：

- 客户端往某个主题发送一个 Payload 为空的保留消息，服务端就会删除这个主题下的保留消息；
- 在 MQTT 服务器上删除，比如 EMQX MQTT 服务器提供了在 Dashboard 上删除保留消息的功能；
- MQTT 5.0 新增了消息过期间隔属性，发布时可使用该属性设置消息的过期时间，不管消息是否为保留消息，都将会在过期时间后自动被删除。

### 使用场景

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20240425133529.png)


## 三、MQTT 持久会话与 Clean Session 详解

### MQTT 持久会话
不稳定的网络及有限的硬件资源是物联网应用需要面对的两大难题，MQTT 客户端与服务器的连接可能随时会因为网络波动及资源限制而异常断开。为了解决网络连接断开对通信造成的影响，MQTT 协议提供了持久会话功能。

MQTT 客户端在发起到服务器的连接时，可以设置是否创建一个持久会话。持久会话会保存一些重要的数据，以使会话能在多个网络连接中继续。持久会话主要有以下三个作用：

- 避免因网络中断导致需要反复订阅带来的额外开销。
- 避免错过离线期间的消息。
- 确保 QoS 1 和 QoS 2 的消息质量保证不被网络中断影响。

### 持久会话需要存储哪些数据

通过上文我们知道持久会话需要存储一些重要的数据，以使会话能被恢复。这些数据有的存储在客户端，有的则存储在服务端。

客户端中存储的会话数据：

- 已发送给服务端，但是还没有完成确认的 QoS 1 与 QoS 2 消息。
- 从服务端收到的，但是还没有完成确认的 QoS 2 消息。

服务端中存储的会话数据：

- 会话是否存在，即使会话状态其余部分为空。
- 已发送给客户端，但是还没有完成确认的 QoS 1 与 QoS 2 消息。
- 等待传输给客户端的 QoS 0 消息（可选），QoS 1 与 QoS 2 消息。
- 从客户端收到的，但是还没有完成确认的 QoS 2 消息，遗嘱消息和遗嘱延时间隔。


>[!Warning] 持久会话能被恢复的前提是客户端使用固定的 Client ID 再次连接，如果 Client ID 是动态的，那么连接成功后将会创建一个新的持久会话。

### MQTT 5.0 中的会话改进

MQTT 5.0 中将 Clean Session 拆分成了 Clean Start 与 Session Expiry Interval。Clean Start 用于指定连接时是创建一个全新的会话还是尝试复用一个已存在的会话，Session Expiry Interval 用于指定网络连接断开后会话的过期时间。

Clean Start 为 `true` 时表示必须丢弃任何已存在的会话，并创建一个全新的会话；为 `false` 时表示必须使用与 Client ID 关联的会话来恢复与客户端的通信（除非会话不存在）。
#### 当会话结束后，保留消息还存在么？

>[!Warning] MQTT 保留消息不是会话状态的一部分，它们不会在会话结束时被删除。。
## 四、Clean Start 与 Session Expiry Interval 介绍与示例

###  为什么需要会话？

在物联网场景中，设备可能因为网络问题或者电源问题而频繁地断开连接。如果客户端和服务端总是以全新的上下文建立连接，那么将带来以下几个问题：

1. 客户端在重连后必须重新订阅主题才能继续接收消息，这会给服务器带来额外的开销。
2. 客户端将会错过离线期间的消息。
3. QoS 1 和 QoS 2 的服务质量将无法得到保证。

为了避免这些问题，MQTT 协议设计了会话机制，它也构成了 MQTT 通信的基础。

### MQTT Clean Session 的使用
Clean Session 是用来控制会话状态生命周期的标志位，为 `true` 时表示创建一个新的会话，在客户端断开连接时，会话将自动销毁。为 `false` 时表示创建一个持久会话，在客户端断开连接后会话仍然保持，直到会话超时注销。


### 什么是 MQTT 会话？

[MQTT 会话](https://www.emqx.com/zh/blog/mqtt-session)本质上就是一组需要服务端和客户端额外存储的上下文数据，这些数据可以仅持续与网络连接一样长的时间，也可以跨越多个连续的网络连接存在。当客户端与服务端借助这些会话数据恢复通信时，可以让网络中断就像从未发生过一样。

以服务端为例，它需要存储客户端的订阅列表，那么不管当前客户端是否连接，只要会话没有过期，服务端就能够知道哪些消息是被该客户端订阅的，进而为它缓存这些消息。另外，客户端再次连接时也不需要重新发起订阅，这也减少了服务端的性能开销。

MQTT 为服务端和客户端分别定义了它们需要存储的会话状态。对于 **服务端** 来说，它需要存储以下内容：

1. 会话是否存在。
2. 客户端的订阅列表。
3. 已发送给客户端，但是还没有完成确认的 QoS 1 和 QoS 2 消息。
4. 等待传输给客户端的 QoS 0 消息（可选），QoS 1 和 QoS 2 消息。
5. 从客户端收到的，但是还没有完成确认的 QoS 2 消息。
6. [遗嘱消息与遗嘱过期间隔](https://www.emqx.com/zh/blog/use-of-mqtt-will-message)。
7. 会话过期时间。

对于 **客户端** 来说，它需要存储以下内容：

1. 已发送给服务端，但是还没有完成确认的 QoS 1 和 QoS 2 消息。
2. 从服务端收到的，但是还没有完成确认的 QoS 2 消息。

显而易见的是，让服务端和客户端永久存储这些会话数据，不仅会带来很多额外的存储成本，而且在很多场景中也没有必要。譬如我们只是为了避免网络连接短暂中断导致的消息丢失，那么一般将会话数据设置为在连接断开后保留短暂的几分钟即可。

另外，当客户端与服务端会话状态不一致时，比如客户端设备因为重启导致会话数据丢失，那么它需要在连接时告知服务端丢弃原有的会话并创建一个全新的会话。

针对这两点，[MQTT 5.0](https://www.emqx.com/zh/blog/introduction-to-mqtt-5) 提供了 Clean Start 和 Session Expiry Interval 这两个连接字段来控制会话的生命周期。

Clean Start 位于 CONNECT 报文的 [可变报头](https://www.emqx.com/zh/blog/introduction-to-mqtt-control-packets)，客户端在连接时通过这个字段指定是否复用已存在的会话，它只有 0 和 1 两个可取值。

**当 Clean Start 被设置为 0**，如果服务端存在与客户端连接时指定的 Client ID 关联的会话，那么它必须使用这个会话来恢复通信。

如果不存在任何与该 Client ID 关联的会话，则服务端必须创建一个全新的会话。这时，客户端使用的是旧的会话，服务端使用的是全新的会话，两边的会话状态出现了不一致。所以服务端必须将 CONNACK 报文中的 Session Present 字段设置为 0，以让客户端知晓它期望的会话不存在，如果客户端想要继续此网络连接，就必须丢弃它保存的会话状态。

**当 Clean Start 设置为 1**，客户端和服务端必须丢弃任何已存在的会话，并开始一个全新的会话。相应地，服务端也会把 CONNACK 报文中的 Session Present 字段设置为 0。

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20240425134731.png)
### Session Expiry Interval 介绍

Session Expiry Interval 同样位于 CONNECT 报文的可变报头，不过它是一个可选的连接 [属性](https://www.emqx.com/zh/blog/introduction-to-mqtt-control-packets)。**它被用来指定会话在网络断开后能够在服务端保留的最长时间**，如果到达过期时间但网络连接仍未恢复，服务端就会丢弃对应的会话状态。它有三个典型的值：

1. **没有指定此属性或者设置为 0**，表示会话将在网络连接断开时立即结束。
2. **设置为一个大于 0 的值**，则表示会话将在网络连接断开的多少秒之后过期。
3. **设置为 0xFFFFFFFF**，即 Session Expiry Interval 属性能够设置的最大值时，表示会话永不过期。

每个 MQTT 客户端都可以独立设置自己的 Session Expiry Interval，我们可以根据实际需要来灵活地设置过期时间，比如一部分客户端不需要持久会话，一部分客户端只需要会话保留几分钟来避免网络波动带来的影响，而另一部分客户端则可能需要会话保留更长的时间。

MQTT 还允许客户端在断开连接时更新会话过期时间，这主要依靠 DISCONNECT 报文中 Session Expiry Interval 属性实现。比较常见的一个应用场景是，客户端在上线时将会话过期时间设置为一个大于 0 的值，避免网络中断影响正常业务。然后在客户端完成所有业务主动下线时，将会话过期时间更新为 0，这样服务端也可以及时地释放会话。

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20240425135025.png)
###  会话与 Client ID
服务端使用 Client ID 来唯一地标识每个会话，如果客户端想要在连接时复用之前的会话，那么必须使用与此前一致的 Client ID。所以当我们使用服务端自动分配 Client ID 的功能时，客户端必须将 CONNACK 报文中返回的 Assigned Client Identifier 保存下来以供下次使用。

注意，MQTT 5.0 之前的协议版本并不支持服务端返回自动分配的 Client ID，所以在由服务端自动分配 Client ID 和使用持久会话之间，我们只能二选一。

### 源文档
- [MQTT 持久会话与 Clean Session 详解](https://www.emqx.com/zh/blog/mqtt-session)
## 五、MQTT遗嘱消息 （Will Message）

### 什么是 MQTT 遗嘱消息？

在现实世界中，一个人可以制定一份遗嘱，声明在他去世后应该如何分配他的财产以及应该采取什么行动。在他去世后，遗嘱执行人会将这份遗嘱公开，并执行遗嘱中的指示。

在 MQTT 中，客户端可以在连接时在服务端中注册一个遗嘱消息，与普通消息类似，我们可以设置遗嘱消息的主题、有效载荷等等。当该客户端意外断开连接，服务端就会向其他订阅了相应主题的客户端发送此遗嘱消息。这些接收者也因此可以及时地采取行动，例如向用户发送通知、切换备用设备等等。

假设我们有一个传感器监控一个很少变化的值，普通的实现是定期发布最新数值，但更好的实现是仅在数值发生变化时以保留消息的形式发送它。这使得任何新的订阅者总能立即获得当前值，而不必等待传感器再一次发布。不过订阅者也因此没有办法根据是否及时收到消息来判断传感器是否离线。借助遗嘱消息，我们可以立即得知传感器保持活动超时，而且不必总是获取传感器发布的值。


![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20240425165847.png)


### Will Message 还是 Last Will and Testament（LWT）？

在一些博客或者代码中，我们可能会看到 Last Will and Testament 这个名字，或者是它的缩写：LWT。它指的就是 MQTT 中的 Will Message。导致这两种命名共存的原因可能是，MQTT 最早在 3.1 协议规范的摘要中，提到了 Last Will and Testament 这个概念。

虽然 MQTT 在协议的正文部分一直以来都是明确使用 Will Message 这个名字，但目前在用户群体中，这两个名字经常会被混用。

我们无意去纠正其中任何一个用法，我们只是希望不同的名字不会让你感到困惑。

### 客户端在连接时指定遗嘱消息

遗嘱消息在客户端发起连接时指定，它和 Client ID、Clean Start 这些字段一起包含在客户端发送的 CONNECT 报文中。

与普通消息一样，我们可以为遗嘱消息设置主题（Will Topic）、保留消息标识位（Will Retain）、属性（Will Properties）、QoS（Will QoS）和有效载荷（Will Payload）

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20240425140727.png)

这些字段的用法与它们在普通消息中时完全相同，只是遗嘱消息可用的属性与普通应用消息略有不同，下表列出了它们的具体区别：

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20240425140747.png)
遗嘱消息总是在客户端“死亡”后被发布，在某种意义上，它也是客户端发出的最后一个消息。所以主题别名在遗嘱消息中没有任何意义。

除此之外，遗嘱消息只是多了一个专属属性：**Will Delay Interval**。它是 [MQTT 5.0](https://www.emqx.com/zh/blog/introduction-to-mqtt-5) 为遗嘱消息引入的一个重要改进，我们会在后文中详细介绍它。

### 服务端仅在连接意外关闭时发布遗嘱消息

如果客户端在连接时指定了遗嘱消息，那么服务端就会将该遗嘱消息存储在相应的会话中，直到以下任一条件满足时发布它：

1. 服务端检测到了一个 I/O 错误或者网络故障
2. 客户端在 Keep Alive 时间内未能通讯
3. 客户端在没有发送 Reason Code 为 0x00（正常关闭）的 DISCONNECT 报文的情况下关闭了网络连接
4. 服务端在没有收到 Reason Code 为 0x00（正常关闭）的 DISCONNECT 报文的情况下关闭了网络连接，例如客户端的报文或行为不符合协议要求而被服务端关闭连接。

简单起见，我们可以直接概括为，只要网络连接在服务端没有收到 Reason Code 为 0x00 的 DISCONNECT 报文的情况下关闭，那么服务端都需要发送遗嘱消息。

当客户端完成了预定的工作准备正常下线时，可以发送一个 Reason Code 为 0x00 的 DISCONNECT 报文然后关闭网络连接，避免服务端因此发布遗嘱消息。

### Will Delay Interval 与延迟发布

默认情况下，服务端总是在网络连接意外关闭时立即发布遗嘱消息。但是很多时候，网络连接的中断是短暂的，所以客户端往往能够重新连接并继续之前的会话。这导致遗嘱消息可能被频繁地且无意义地发送。

所以 MQTT 5.0 专门为遗嘱消息增加了一个 Will Delay Interval 属性，这个属性决定了服务端将在网络连接关闭后延迟多久发布遗嘱消息，并以秒为单位。

如果没有指定 Will Delay Interval 或者将其设置为 0，服务端将仍然在网络连接关闭时立即发布遗嘱消息。

但如果将 Will Delay Interval 设置为一个大于 0 的值，并且客户端能够在 Will Delay Interval 到期前恢复连接，那么该遗嘱消息将不会被发布。

### 遗嘱消息与会话

>[!TIP] 遗嘱消息是服务端会话状态的一部分，当会话结束，遗嘱消息也无法继续单独存在。

但是在遗嘱消息延迟发布期间，会话可能过期，也可能因为客户端在新的连接中设置 Clean Start 为 1 所以服务端需要丢弃之前的会话。

为了避免丢失遗嘱，此时服务端必须发布该遗嘱消息，即便 Will Delay Interval 还没有到期。

所以服务端最终何时发布遗嘱消息，取决于 Will Delay Interval 到期和会话结束这两种情况谁先发生。

### MQTT 3.1.1 中的遗嘱消息

在 MQTT 3.1.1 中，只要网络连接在服务端没有收到 DISCONNECT 报文的情况下关闭，服务端都需要发布遗嘱消息。

由于 MQTT 3.1.1 没有 Will Delay Interval，也没有 Session Expiry Interval，所以遗嘱消息总是在网络连接关闭时立即发布。
### 为什么没有收到遗嘱消息？

遗嘱消息的延迟发布和取消发布让订阅端最终是否会收到遗嘱消息这个问题变得稍显复杂。

我们对所有可能的情况进行了梳理，以便让大家更好地理解：

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20240425141422.png)

1. 连接意外关闭且 Will Delay Interval 等于 0，遗嘱消息将在网络连接关闭时立即发布
2. 连接意外关闭且 Will Delay Interval 大于 0，遗嘱消息将被延迟发布，最大延迟时间取决于 Will Delay Interval 与 Session Expiry Interval 谁先到期：
    1. 客户端未能在 Will Delay Interval 或 Session Expiry Interval 到期前恢复连接，遗嘱消息将被发布。
    2. 在 Will Delay Interval 或 Session Expiry Interval 到期前
        1. 客户端指定 Clean Start 为 0 恢复连接，遗嘱消息将不会被发布。
        2. 客户端指定 Clean Start 为 1 恢复连接，遗嘱消息将因为 **现有会话结束** 而被立即发布。

如果现有网络连接尚未断开，但客户端使用相同 Client ID 发起新的连接，服务端会向现有的网络连接发送一个 Reason Code 为 0x8E（Session Taken Over）的 DISCONNECT 报文然后关闭它。这种情况在网络不佳时非常容易出现，但也属于连接意外关闭。

现在，请思考这样一个问题：如果现有的网络连接的 Session Expiry Interval 等于 0，Will Delay Interval 大于 0，那么当客户端指定 Clean Start 为 0 发起新的网络连接时服务端是否会发送遗嘱消息？

答案是遗嘱消息将在现有的网络连接断开时被立即发布。

当服务端关闭现有的网络连接，由于 Session Expiry Interval 为 0，会话也将立即结束。虽然 Clean Start 设置为 0，但服务端将为新的网络连接创建了一个新的会话。所以遗嘱消息将因为会话结束而被发布，即满足了上面所列情形中的 2.1 而不是 2.2.1。。

### 遗嘱消息使用技巧

#### 与保留消息一起使用

服务端一旦发布了遗嘱消息，就会将它从会话中删除。如果关心此遗嘱消息的客户端不在线，那么它就错过了这条遗嘱消息。

为了避免这种情况，我们**可以将遗嘱消息设置为保留消息**，这样遗嘱消息在被发布后，还会以保留消息的形式存储在服务端中，客户端可以在任何时候获取这条遗嘱消息。

如果更进一步，我们还可以实现对指定客户端的状态监控。

让客户端 `myclient` 在每次连接时都指定一个主题为 `myclient/status`，有效载荷为 `offline` 并且设置了 Will Retain 标志的遗嘱消息。每当连接成功，就向主题 `myclient/status` 发布一个有效载荷为 `online` 的保留消息。这样，我们就可以随时订阅主题 `myclient/status`，来获取客户端 `myclient` 的最新状态。

#### 会话过期通知

通过设置一个大于 Session Expiry Interval 的 Will Delay Interval，服务端可以以遗嘱消息的形式发出会话过期通知。这对于一些更关心会话过期而不是网络连接中断的应用更加有用。即便是主动下线，客户端可以发送一个 Reason Code 为 0x04 的 DISCONNECT 报文要求服务端仍然发送遗嘱消息。

## 六、MQTT 发布/订阅模式介绍

### MQTT 发布/订阅模式

发布订阅模式（Publish-Subscribe Pattern）是一种消息传递模式，它将发送消息的客户端（发布者）与接收消息的客户端（订阅者）解耦，使得两者不需要建立直接的联系也不需要知道对方的存在。

MQTT 发布/订阅模式的精髓在于由一个被称为代理（Broker）的中间角色负责所有消息的路由和分发工作，发布者将带有主题的消息发送给代理，订阅者则向代理订阅主题来接收感兴趣的消息。

在 MQTT 中，主题和订阅无法被提前注册或创建，所以代理也无法预知某一个主题之后是否会有订阅者，以及会有多少订阅者，所以只能将消息转发给当前的订阅者，**如果当前不存在任何订阅，那么消息将被直接丢弃。**

MQTT 发布/订阅模式有 4 个主要组成部分：发布者、订阅者、代理和主题。

- **发布者（Publisher）**
    
    负责将消息发布到主题上，发布者一次只能向一个主题发送数据，发布者发布消息时也无需关心订阅者是否在线。
    
- **订阅者（Subscriber）**
    
    订阅者通过订阅主题接收消息，且可一次订阅多个主题。MQTT 还支持通过[共享订阅](https://www.emqx.com/zh/blog/introduction-to-mqtt5-protocol-shared-subscription)的方式在多个订阅者之间实现订阅的负载均衡。
    
- **代理（Broker）**
    
    负责接收发布者的消息，并将消息转发至符合条件的订阅者。另外，代理也需要负责处理客户端发起的连接、断开连接、订阅、取消订阅等请求。
    
- **主题（Topic）**
    
    主题是 MQTT 进行消息路由的基础，它类似 URL 路径，使用斜杠 `/` 进行分层，比如 `sensor/1/temperature`。一个主题可以有多个订阅者，代理会将该主题下的消息转发给所有订阅者；一个主题也可以有多个发布者，代理将按照消息到达的顺序转发。
    
    MQTT 还支持订阅者使用主题通配符一次订阅多个主题。更多关于 MQTT 主题的介绍可查看博客：[通过案例理解 MQTT 主题与通配符](https://www.emqx.com/zh/blog/advanced-features-of-mqtt-topics)。
    
![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20240425142511.png)

### MQTT 发布/订阅中的消息路由

在 MQTT 发布/订阅模式中，一个客户端既可以是发布者，也可以是订阅者，也可以同时具备这两个身份。 当客户端发布一条消息时，它会被发送到代理，然后代理将消息路由到该主题的所有订阅者。 当客户端订阅一个主题时，它会收到代理转发到该主题的所有消息。

一般来说，大多数发布/订阅系统主要通过以下两种方式过滤并路由消息。

- 根据主题
    
    订阅者向代理订阅自己感兴趣的主题，发布者发布的所有消息中都会包含自己的主题，代理根据消息的主题判断需要将消息转发给哪些订阅者。
    
- 根据消息内容
    
    订阅者定义其感兴趣的消息的条件，只有当消息的属性或内容满足订阅者定义的条件时，消息才会被投递到该订阅者。
    

MQTT 协议是基于主题进行消息路由的，在这个基础上，EMQX 从 3.1 版本开始通过基于 SQL 的规则引擎提供了额外的按消息内容进行路由的能力。关于规则引擎的详细信息，请查看 [EMQX 文档](https://www.emqx.io/docs/zh/v5.0/data-integration/rules.html)。

### MQTT 与 HTTP 请求响应

HTTP 是万维网数据通信的基础，其简单易用无客户端依赖，被广泛应用于各个行业。在物联网领域，HTTP 也可以用于连接物联网设备和 Web 服务器，实现设备的远程监控和控制。

虽然使用简单、开发周期短，但是基于请求响应的 HTTP 在物联网领域的应用却有一定的局限性。首先，协议层面 HTTP 报文相较与 MQTT 需要占用更多的网络开销；其次，HTTP 是一种无状态协议，这意味着服务器在处理请求时不会记录客户端的状态，也无法实现从连接异常断开中恢复；最后，请求响应模式需要通过轮询才能获取数据更新，而 MQTT 通过订阅即可获取实时数据更新。

发布订阅模式的松耦合特性，也给 MQTT 带来了一些副作用。由于发布者并不知晓订阅者的状态，因此发布者也无法得知订阅者是否收到了消息，或者是否正确处理了消息。为此，MQTT 5.0 增加了[请求响应](https://www.emqx.com/zh/blog/mqtt5-request-response)特性，以实现订阅者收到消息后向某个主题发送应答，发布者收到应答后再进行后续操作。

### MQTT 与消息队列

尽管 MQTT 与消息队列的很多行为和特性非常接近，比如都采用发布/订阅模式，但是他们面向的场景却有着显著的不同。消息队列主要用于服务端应用之间的消息存储与转发，这类场景往往数据量大但客户端数量少。MQTT 是一种消息传输协议，主要用于物联网设备之间的消息传递，这类场景的特点是海量的设备接入、管理与消息传输。

在一些实际的应用场景中，MQTT 与消息队列往往会被结合起来使用，以使 MQTT 服务器能专注于处理设备的连接与设备间的消息路由。比如先由 MQTT 服务器接收物联网设备上报的数据，然后再通过消息队列将这些数据转发到不同的业务系统进行处理。

不同于消息队列，MQTT 主题不需要提前创建。[MQTT 客户端](https://www.emqx.com/zh/blog/mqtt-client-tools)在订阅或发布时即自动的创建了主题，开发者无需再关心主题的创建，并且也不需要手动删除主题。


## 七、MQTT 主题和通配符

MQTT 主题本质上是一个 UTF-8 编码的字符串，是 MQTT 协议进行消息路由的基础。MQTT 主题类似 URL 路径，使用斜杠 `/` 进行分层：

```
chat/room/1
sensor/10/temperature
sensor/+/temperature
sensor/#
```
为了避免歧义且易于理解，通常不建议主题以 `/` 开头或结尾，例如 `/chat` 或 `chat/`。
### MQTT 主题通配符

MQTT 主题通配符包含单层通配符 `+` 及多层通配符 `#`，主要用于客户端一次订阅多个主题。

>[!Warning] 通配符只能用于订阅，不能用于发布。

### 单层通配符

加号 (“+” U+002B) 是用于单个主题层级匹配的通配符。在使用单层通配符时，单层通配符必须占据整个层级，例如：

```
+ 有效
sensor/+ 有效
sensor/+/temperature 有效
sensor+ 无效（没有占据整个层级）
```

如果客户端订阅了主题 `sensor/+/temperature`，将会收到以下主题的消息：
```
sensor/1/temperature
sensor/2/temperature
...
sensor/n/temperature
```

但是不会匹配以下主题
```
sensor/temperature
sensor/bedroom/1/temperature
```

### 多层通配符

井字符号（“#” U+0023）是用于匹配主题中任意层级的通配符。多层通配符表示它的父级和任意数量的子层级，在使用多层通配符时，它必须占据整个层级并且必须是主题的最后一个字符，例如：
```
# 有效，匹配所有主题
sensor/# 有效
sensor/bedroom# 无效（没有占据整个层级）
sensor/#/temperature 无效（不是主题最后一个字符）
```

如果客户端订阅主题 `senser/#`，它将会收到以下主题的消息：
```
sensor
sensor/temperature
sensor/1/temperature
```

###  以 $ 开头的主题

#### 系统主题

以 `$SYS/` 开头的主题为系统主题，系统主题主要用于获取 [MQTT 服务器](https://www.emqx.com/zh/mqtt/public-mqtt5-broker)自身运行状态、消息统计、客户端上下线事件等数据。目前，MQTT 协议暂未明确规定 `$SYS/` 主题标准，但大多数 MQTT 服务器都遵循该[标准建议](https://github.com/mqtt/mqtt.org/wiki/SYS-Topics)。

### 常见的 MQTT 主题使用建议有哪些？

- 不建议使用 `#` 订阅所有主题；
- 不建议主题以 `/` 开头或结尾，例如 `/chat` 或 `chat/`；
- 不建议在主题里添加空格及非 ASCII 特殊字符；
- 同一主题层级内建议使用下划线 `_` 或横杆 `-` 连接单词（或者使用驼峰命名）；
- 尽量使用较少的主题层级；
- 当使用通配符时，将唯一值的主题层（例如设备号）越靠近第一层越好。例如，`device/00000001/command/#` 比`device/command/00000001/#` 更好。

### 主题的层级及长度有什么限制吗？

MQTT 协议规定主题的长度为两个字节，因此主题最多可包含 **65,535** 个字符。

建议主题层级为 7 个以内。使用较短的主题名称和较少的主题层级意味着较少的资源消耗，例如 `my-home/room1/data` 比 `my/home/room1/data` 更好。

## MQTT共享订阅
在普通的订阅中，我们每发布一条消息，所有匹配的订阅端都会收到该消息的副本。当某个订阅端的消费速度无法跟上消息的生产速度时，我们没有办法将其中一部分消息分流到其他订阅端中来分担压力。这使订阅端容易成为整个消息系统的性能瓶颈。

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20240425150657.png)


所以 MQTT 5.0 引入了共享订阅特性，它使得 MQTT 服务端可以在使用特定订阅的客户端之间均衡地分配消息负载。这表示，当我们有两个客户端共享一个订阅时，那么每个匹配该订阅的消息都只会有一个副本投递给其中一个客户端。

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20240425150715.png)


共享订阅不仅为消费端带来了极佳的水平扩展能力，使我们可以应对更高的吞吐量，还为其带来了高可用性，即使共享订阅组中的一个客户端断开连接或发生故障，其他客户端仍然可以继续处理消息，在必要时还可以接管原先流向该客户端的消息流。

### 共享订阅如何工作
使用共享订阅，我们不需要对客户端的底层代码进行任何改动，只需要在订阅时使用遵循以下命名规范的主题即可：
```
$share/{Share Name}/{Topic Filter}
```

其中 `$share` 是一个固定的前缀，以便服务端知道这是一个共享订阅主题。`{Topic Filter}` 则是我们实际想要订阅的主题。

中间的 `{Share Name}` 是一个由客户端指定的字符串，表示当前共享订阅使用的共享名。很多时候，`{Share Name}` 这个字段也会被叫作 Group Name 或者 Group ID，这确实会更容易理解一些。
需要共享同一个订阅的一组订阅会话，必须使用相同的共享名。所以 `$share/consumer1/sport/#` 和 `$share/consumer2/sport/#` 属于不同的共享订阅组。当一个消息同时与多个共享订阅组使用的过滤器匹配时，服务端会在每个匹配的共享订阅组中选择一个会话发送该消息的副本。这在某个主题的消息有多个不同类型的消费者时非常有用。

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20240425150746.png)

但是，两个订阅的共享名 `{Share Name}` 相同，并不表示它们一定是相同的共享订阅。只有 `{Share Name}/{Topic Filter}` 才能唯一地标识一个共享订阅组，下面这些订阅主题均属于不同的共享订阅组：

- `$share/consumer1/sport/tennis/+`
- `$share/consumer2/sport/tennis/+`
- `$share/consumer1/sport/#`
- `$share/comsumer1/finance/#`

共享订阅和普通订阅互不影响，当某个消息同时与共享订阅和普通订阅匹配时，服务端会向每个匹配的普通订阅的客户端发送该消息的副本，同时向每个匹配的共享订阅组中的其中一个会话发送该消息的副本。如果这些订阅来自同一个客户端，那么这个客户端可能会收到该消息的多个副本。

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20240425150802.png)

### 共享订阅的负载均衡策略

共享订阅的核心在于服务端如何在客户端之间分配消息负载。比较常见的负载均衡策略有以下几种：

- 随机（Random），在共享订阅组内随机选择一个会话发送消息。
- 轮询（Round Robin），在共享订阅组内按顺序选择一个会话发送消息，循环往复。
- 哈希（Hash），基于某个字段的哈希结果来分配。
- 粘性（Sticky），在共享订阅组内随机选择一个会话发送消息，此后保持这一选择，直到该会话结束再重复这一过程。
- 本地优先（Local），随机选择，但优先选择与消息的发布者处于同一节点的会话，如果不存在这样的会话，则退化为普通的随机策略。

**随机** 和 **轮询** 这两种策略实现的均衡效果较为接近，所以它们在应用场景上的区别不大，但 **随机** 策略实际的均衡效果通常还会受到服务端采用的随机算法的影响。

在实际应用中，消息之间可能存在关联，比如属于同一张图片的多个分片显然不适合分发给多个订阅者。在这种情况下，我们就需要基于 Client ID 或者 Topic 的 **哈希** 策略来选择会话。这可以保证来自同一个发布端或者主题的消息始终由共享订阅组中的同一个会话处理。当然，**粘性** 策略也有相同的效果。

**本地优先** 策略比 **随机** 策略更合适在集群中使用，优先选择本地订阅端的策略可以有效降低消息的延迟。不过使用这一策略的前提是我们可以确保发布端和订阅端比较均衡地分布在每个节点上，以免不同订阅端上的消息负载差别过大。

### 共享订阅使用场景

以下是几个典型的共享订阅的使用场景：

- 后端消费能力与消息的生产能力不匹配时，我们可以借助共享订阅让更多的客户端一起分担负载。
- 系统需要保证高可用性，特别是在大量消息流入的关键业务上，我们可以通过共享订阅来避免单点故障。
- 消息的流入量可能会在未来快速增长，需要消费端能够水平扩展，我们可以通过共享订阅来提供高扩展性。

### 共享订阅使用建议

#### 在共享订阅组内使用相同的 QoS

MQTT 虽然允许一个共享订阅组内的会话使用不同的 QoS 等级，但这可能会使消息在投递给同一个组内的不同会话时存在不同的质量保证。相应地，在出现一些问题的时候，我们的调试也将变得困难重重。所以我们最好在共享订阅组内使用相同的 QoS。

#### 合理地设置会话过期时间

持久会话与共享订阅一起使用是非常常见的。但需要注意，即便共享订阅组中的某个客户端离线，但只要它的会话与订阅仍在存在时，MQTT 服务端仍然会向此会话分发消息。考虑到客户端可能因为故障等原因长时间离线，如果会话的过期时间过长，那么这段时间内将有很多消息因为被投递给离线客户端而无法得到处理。

一个更好的选择可能是，一旦订阅端离线，即便会话没有过期，MQTT 服务端在分配消息负载时也不再考虑这个订阅端。虽然与普通订阅的行为不同，但这是 [MQTT 协议](https://www.emqx.com/zh/blog/the-easiest-guide-to-getting-started-with-mqtt)允许的。

## MQTT协议规范
- [阿里云# MQTT协议规范](https://help.aliyun.com/zh/iot/user-guide/mqtt-protocol?spm=a2c4g.11186623.0.i2)