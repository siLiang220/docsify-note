# 系统架构
![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/uTools_1660974176438.png)
-  **Name Server**：是一个几乎无状态节点，可集群部署，在消息队列RocketMQ版中提供命名服务，更新和发现Broker服务。
-   **Broker**：消息中转角色，负责存储消息，转发消息。分为Master Broker和Slave Broker，一个Master Broker可以对应多个Slave Broker，但是一个Slave Broker只能对应一个Master Broker。Broker启动后需要完成一次将自己注册至Name Server的操作；随后每隔30s定期向Name Server上报Topic路由信息。
-   **生产者**：与Name Server集群中的其中一个节点（随机）建立长连接（Keep-alive），定期从Name Server读取Topic路由信息，并向提供Topic服务的Master Broker建立长连接，且定时向Master Broker发送心跳。
-   **消费者**：与Name Server集群中的其中一个节点（随机）建立长连接，定期从Name Server拉取Topic路由信息，并向提供Topic服务的Master Broker、Slave Broker建立长连接，且定时向Master Broker、Slave Broker发送心跳。Consumer既可以从Master Broker订阅消息，也可以从Slave Broker订阅消息，订阅规则由Broker配置决定。
# 基本概念
#### topic
消息主题，一级消息类型，通过topic进行分类
#### tag
消息标签，二级消息类型，用来进一步区分某个topic下的消息分类
#### producer
消息生产者
#### message
消息队列中的消息载体
#### Message ID
消息的全局唯一标识，由消息队列rocketMq系统生成，唯一标识某条消息
#### Message Key
消息的业务标识，由消息生产者设置
#### Consumer
消息消费者，负责接收消费消息
- Push Consumer : 由消费者队列推送的consumer
- Pull Consumer : consumer 主动从消息队列拉取消息
#### 分区
topic partition物理概念，每个topic下包含一个或多个分区
#### 消费者点位
每个Topic会有多个分区，每个分区会统计当前消息的总条数，这个称为最大位点MaxOffset；分区的起始位置对应的位置叫做起始位点MinOffset。

消息队列RocketMQ版的Pull Consumer会按顺序依次消费分区内的每条消息，记录已经消费了的消息条数，称为消费位点ConsumerOffset。剩余的未消费的条数（也称为消息堆积量）= 最大位点MaxOffset-消费位点ConsumerOffset。
#### group
一类Producer或Consumer，这类Producer或Consumer通常生产或消费同一类消息，且消息发布或订阅的逻辑一致。
#### Group ID
group 的标识
#### 队列
每个Topic下会由一到多个队列来存储消息。每个Topic对应队列数与消息类型
#### 集群消费
一个Group ID所标识的所有Consumer平均分摊消费消息。例如某个Topic有9条消息，一个Group ID有3个Consumer实例，那么在集群消费模式下每个实例平均分摊，只消费其中的3条消息。
#### 广播消费
一个Group ID所标识的所有Consumer都会各自消费某条消息一次。例如某个Topic有9条消息，一个Group ID有3个Consumer实例，那么在广播消费模式下每个实例都会各自消费9条消息。
#### 定时消息
Producer将消息发送到消息队列RocketMQ版服务端，但并不期望这条消息立马投递，而是推迟到在当前时间点之后的某一个时间投递到Consumer进行消费，该消息即定时消息。
#### 延时消息
Producer将消息发送到消息队列RocketMQ版服务端，但并不期望这条消息立马投递，而是延迟一定时间后才投递到Consumer进行消费，该消息即延时消息。
#### 事务消息
消息队列RocketMQ版提供类似XA或Open XA的分布事务功能，通过消息队列RocketMQ版的事务消息能达到分布式事务的最终一致。
#### 顺序消息
消息队列RocketMQ版提供的一种按照顺序进行发布和消费的消息类型，分为全局顺序消息和分区顺序消息。
#### 全局顺序消息
对于指定的一个Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。
#### 分区顺序消息
对于指定的一个Topic，所有消息根据Sharding Key进行区块分区。同一个分区内的消息按照严格的FIFO顺序进行发布和消费。Sharding Key是顺序消息中用来区分不同分区的关键字段，和普通消息的Message Key是完全不同的概念。
#### 消息堆积
Producer已经将消息发送到消息队列RocketMQ版的服务端，但由于Consumer消费能力有限，未能在短时间内将所有消息正确消费掉，此时在消息队列RocketMQ版的服务端保存着未被消费的消息，该状态即消息堆积。
**消息堆积量=处理中的消息+已就绪的消息**
#### 消息过滤
Consumer可以根据消息标签（Tag）对消息进行过滤，确保Consumer最终只接收被过滤后的消息类型。消息过滤在消息队列RocketMQ版的服务端完成。
#### 消息轨迹
在一条消息从Producer发出到Consumer消费处理过程中，由各个相关节点的时间、地点等数据汇聚而成的完整链路信息。通过消息轨迹，您能清晰定位消息从Producer发出，经由消息队列RocketMQ版服务端，投递给Consumer的完整链路，方便定位排查问题。
#### 重置消息位点
以时间轴为坐标，在消息持久化存储的时间范围内（默认3天），重新设置Consumer对已订阅的Topic的消费进度，设置完成后Consumer将接收设定时间点之后由Producer发送到消息队列RocketMQ版服务端的消息
#### 死信队列
死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，消息队列RocketMQ版会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明Consumer在正常情况下无法正确地消费该消息。此时，消息队列RocketMQ版不会立刻将消息丢弃，而是将这条消息发送到该Consumer对应的特殊队列中。
消息队列RocketMQ版将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。
#### 消息路由
消息路由常用于不同地域之间的消息同步，保证地域之间的数据一致性。消息队列RocketMQ版的全球消息路由功能依托阿里云优质基础设施实现的高速通道专线，可以高效地实现不同地域之间的消息同步复制
## 普通消息
### 功能简介
在多种消息类型中，普通消息是最简单也最为重要。普通消息是 RocketMQ 的基本消息类型，提供高吞吐、扩展、低延迟、异步的通信能力。其他高级消息类型基本都是在这种普通消息类型的基础上叠加了独有的控制特性，或者是特定的使用的方式。
![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20220821181819.png)
**普通消息的特点**
- 原子性：消息之间没有关联关系，收发处理逻辑原子；
- 扩展性：普通消息容量、能力可扩展，支持多队列存储、水平拆分、并发消费；
- 低延迟：普通消息链路短，交互简单，状态简单，链路极简，毫秒级低延迟通信。
#### 消息的生命周期
![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20220821182037.png)

-   初始化：普通消息被生产者构建初始化完成，待发送到服务端的状态；
    
-   待消费：消息被传输到服务端，对下游可见，等待消费者获取处理的状态；
    
-   消费中：消息被消费者获取，并按照业务逻辑处理过程，此时服务端会等待消费完成，如果一定时间后没有收到消费提交的事件，消息还会重试处理；
    
-   消费提交：消费者完成消息处理，并提交应答事件到服务端，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ默认支持所有消息保留，此时消息数据并不会立即被删除，只是逻辑标记完成，在消息被物理删除之前，消费者仍然可以回溯重新处理消息；
    
-   消息删除：RocketMQ 按照消息保存时间机制滚动清理最早的消息数据，将消息从物理文件中删除。
#### 定时消息的使用场景
1）微服务调用解耦
-   异步化解耦：普通消息实现微服务异步调用，缩短业务流和响应时间。
-   流量削峰填谷：普通消息海量堆积能力，解决流量峰值下游处理能力不足的稳定性风险。
2）实时数据传输
-   高吞吐传输：普通消息可以实现无限水平扩展，数据传输吞吐高，解决采集上报问题。   
-   实时传输：普通消息实时传输投递，下游可以及时消费实现计算和分析。

## 定时消息
在业务消息集成场景中，定时消息是，生产者将一条消息发送到消息队列后并不期望这条消息马上会被消费者消费到，而是期望到了指定的时间，消费者才可以消费到。
对于定时/延时消息来说，其可以理解为在普通消息的基础上叠加了定时投递到消费者的特性。生产者发送了一条定时消息之后，消息并不会马上进入用户真正的Topic里面，而是会被 RocketMQ 暂存到一个系统 Topic 里面，当到了设定的时间之后，RocketMQ 才会将这条消息投递到真正的 Topic 里面，让消费者可以消费到。
![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/uTools_1661076571146.png)

#### 定时消息的使用场景
在分布式定时调度触发、任务超时处理等场景，需要实现精准、可靠的定时事件触发
-   高性能吞吐：需要大量事件触发，不能有性能瓶颈。
-   高可靠可重试：不能丢失事件触发。
-   分布式可扩展：定时调度不能是单机系统，需要能够均衡的调度到多个服务负载。
传统的定时调度方案，往往基于数据库的任务表扫描机制来实现。大概的思路就是将需要定时触发的任务放到数据库，然后微服务应用定时触发扫描数据库的操作，实现任务捞取处理。
_**使用定时消息实现金融支付超时的需求**_
![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/uTools_1661076852962.png)
#### 注意
定时消息的实现逻辑需要先经过定时存储等待触发，定时时间到达后才会被投递给消费者。因此，如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大。所以一般建议尽量不要设置大量相同触发时刻的消息。

## 顺序消息
### 基本概念
顺序消息是消息队列 RocketMQ 版提供的一种对消息发送和消费顺序有严格要求的消息。对于一个指定的 Topic，同一 MessageGroup 的消息按照严格的先进先出（FIFO）原则进行发布和消费，即先发布的消息先消费，后发布的消息后消费，服务端严格按照发送顺序进行存储、消费。同一 MessageGroup 的消息保证顺序，不同 MessageGroup 之间的消息顺序不做要求，因此需做到两点，发送的顺序性和消费的顺序性。
![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20220821174945.png)
在分布式环境下，保证消息的全局顺序性是十分困难的，例如两个 RocketMQ Producer A 与 Producer B，它们在没有沟通的情况下各自向 RocketMQ 服务端发送消息 a 和消息 b，由于分布式系统的限制，我们无法保证 a 和 b 的顺序。因此业界消息系统通常保证的是分区的顺序性，即保证带有同一属性的消息的顺序，我们将该属性称之为 MessageGroup。如图所示，ProducerA 发送了 MessageGroup 属性为 A 的两条消息 A1，A2 和 MessageGroup 属性为 B 的 B1，B2，而 ProducerB 发送了 MessageGroup 属性为 C 的两条属性 C1，C2。  

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/yvBJb5IiafvmHRibibXKmQicfIKHsSZuwWUK0MIgD5mjRu9picShELjZUqlca2xib0jUicnG6wUWSicmNHmTSC3vBLhtow/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

同时，对于同一 MessageGroup，为了保证其发送顺序的先后性，比较简单的做法是构造一个单线程的场景，即不同的 MessageGroup 由不同的 Producer 负责，并且对于每一个 Producer 而言，顺序消息是同步发送的。同步发送的好处是显而易见的，在客户端得到上一条消息的发送结果后再发送下一条，即能准确保证发送顺序，若使用异步发送或多线程则很难保证这一点。 

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/dky8WRYUFZFibJ3zSicbQNQUJDbYAo62rfUWkmKPs0ntg2PGtu9j4icMMOEvjibsEZNs0MbRLKVP1ovL1D4Zp9FtCg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

因此可以看到，虽然在底层原理上，顺序消息发送和普通消息发送并无二异，但是为了保证顺序消息的发送顺序性，同步发送的方式相比较普通消息，实际上降低了消息的最大吞吐。

#### 顺序消费

与顺序消息不同的是，普通消息的消费实际上没有任何限制，消费者拉取的消息是被异步、并发消费的，而顺序消息，需要保证对于同一个 MessageGroup，同一时刻只有一个客户端在消费消息，并且在该条消息被确认消费完成之前（或者进入死信队列），消费者无法消费同一 MessageGroup 的下一条消息，否则消费的顺序性将得不到保证。因此这里存在着一个消费瓶颈，该瓶颈取决于用户自身的业务处理逻辑。极端情况下当某一 MessageGroup 的消息过多时，就可能导致消费堆积。当然也需要明确的是，这里的语境都指的是同一 MessageGroup，不同 MessageGroup 的消息之间并不存在顺序性的关联，是可以进行并发消费的。因此全文中提到的顺序实际上是一种偏序。

![图片](https://mmbiz.qpic.cn/mmbiz_png/yvBJb5IiafvmHRibibXKmQicfIKHsSZuwWUKNCAq6B8ltd007C83icaiccXV5w5ncibdN7klGUw44fyA84ohI9eqDXJKA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)




无论对于发送还是消费，我们通过 MessageGroup 的方式将消息分组，即并发的基本单元是 MessageGroup，不同的 MessageGroup 可以并发的发送和消费，从而一定程度具备了可拓展性，支持多队列存储、水平拆分、并发消费，且不受影响。回顾普通消息，站在顺序消息的视角，可以认为普通消息的并发基本单元是单条消息，即每条消息均拥有不同的 MessageGroup。

我们回到开头那个问题：

> 既然顺序消息能在普通消息的基础上实现顺序，看起来就是普通消息的加强版，那么为什么不全部都使用顺序消息呢？

现在大家对于这个问题可能有一个基本的印象了，消息的顺序性当然很好，但是为了实现顺序性也是有代价的。

下述是一个表格，简要对比了顺序消息和普通消息。  

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/yvBJb5IiafvmHRibibXKmQicfIKHsSZuwWUKzvGJX1DoIck0R94fHRIZfEwEK0OibOTJ0HYexwU8hfFnsLVrDHfsILw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

_**最佳实践**_

#### 合理设置 MessageGroup

MessageGroup 会有很多错误的选择，以某电商平台为例，某电商平台将商家 ID 作为 MessageGroup，因为部分规模较大的商家会产出较多订单，由于下游消费能力的限制，因此这部分商家所对应的订单就发生了严重的堆积。正确的做法应当是将订单号作为 MessageGroup，而且站在背后的业务逻辑上来说，同一订单才有顺序性的要求。即选择 MessageGroup 的最佳实践是：MessageGroup 生命周期最好较为短暂，且不同 MessageGroup 的数量应当尽量相同且均匀。

#### 消费幂等

消息传输链路在异常场景下会有少量重复，业务消费是需要做消费幂等，避免重复处理带来的风险。

_**应用案例**_

-   用户注册需要发送验证码，以用户 ID 作为 MessageGroup，那么同一个用户发送的消息都会按照发布的先后顺序来消费。
-   电商的订单创建，以订单 ID 作为 MessageGroup，那么同一个订单相关的创建订单消息、订单支付消息、订单退款消息、订单物流消息都会按照发布的先后顺序来消费。
 ![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20220821175728.png)


#### 
## 事务消息
([解析 RocketMQ 业务消息——“事务消息” (qq.com)](https://mp.weixin.qq.com/s/efM6kOAdQC3UwuPOAvnDDg))
以 电商交易场景为例，用户支付订单会同时设计下游物流发货，积分变更，购物车状态清空等多个子系统变更
![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/uTools_1661072131352.png)
分布式系统的调用特点：一个核心业务逻辑的执行同时需要调用多个下游业务进行处理。
基于rocketMQ分布式事务消息：支持最终的一致性
而基于消息队列 RocketMQ 版实现的分布式事务消息功能，在普通消息基础上，支持二阶段的提交能力。将二阶段提交和本地事务绑定，实现全局提交结果的一致性。![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/uTools_1661072393119.png)
### 基本原理
#### 基本概念
- **事务消息：** RocketMQ 提供类似 XA 或 Open XA 的分布式事务功能，通过 RocketMQ 事务消息能达到分布式事务的最终一致；
- **半事务消息：** 暂不能投递的消息，生产者已经成功地将消息发送到了 RocketMQ 服务端，但是 RocketMQ 服务端未收到生产者对该消息的二次确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的消息即半事务消息；
- **消息回查：**-   由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，RocketMQ 服务端通过扫描发现某条消息长期处于“半事务消息”时，需要主动向消息生产者询问该消息的最终状态（Commit 或是 Rollback），该询问过程即消息回查。
#### 事务消息生命周期
-   **初始化**：半事务消息被生产者构建并完成初始化，待发送到服务端的状态； 
-   **事务待提交**：半事务消息被发送到服务端，和普通消息不同，并不会直接被服务端持久化，而是会被单独存储到事务存储系统中，等待第二阶段本地事务返回执行结果后再提交。此时消息对下游消费者不可见； 
-   **消息回滚**：第二阶段如果事务执行结果明确为回滚，服务端会将半事务消息回滚，该事务消息流程终止；
-   **提交待消费**：第二阶段如果事务执行结果明确为提交，服务端会将半事务消息重新存储到普通存储系统中，此时消息对下游消费者可见，等待被消费者获取并消费；
-   **消费中**：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ 会对消息进行重试处理。具体信息，请参见消息重试；
-   **消费提交**：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）；RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。
-   **消息删除**：当消息存储时长到期或存储空间不足时，RocketMQ 会按照滚动机制清理最早保存的消息数据，将消息从物理文件中删除。
### 事务消息基本流程
![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20220821170927.png)
1.  生产者将消息发送至 RocketMQ 服务端； 
2.  RocketMQ 服务端将消息持久化成功之后，向生产者返回 Ack 确认消息已经发送成功，此时消息被标记为“暂不能投递”，这种状态下的消息即为半事务消息；
3.  生产者开始执行本地事务逻辑；
4.  生产者根据本地事务执行结果向服务端提交二次确认结果（Commit 或是 Rollback），服务端收到确认结果后处理逻辑如下： 
	+   二次确认结果为 Commit：服务端将半事务消息标记为可投递，并投递给消费者；
	+  二次确认结果为 Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。 

5.  在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为Unknown未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查；
6.  生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果；
7.  生产者根据检查到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤 4 对半事务消息进行处理。
#### 事务消息的注意事项
1.  避免大量未决事务导致超时：在事务提交阶段异常的情况下发起事务回查，保证事务一致性；但生产者应该尽量避免本地事务返回未知结果；大量的事务检查会导致系统性能受损，容易导致事务处理延迟；
2.  事务消息的 Group ID 不能与其他类型消息的 Group ID 共用:与其他类型的消息不同，事务消息有回查机制，回查时服务端会根据 Group ID 去查询生产者客户端；
3.  事务超时机制：半事务消息被生产者发送服务端后，如果在指定时间内服务端无法确认提交或者回滚状态，则消息默认会被回滚。