DDD的核心思想是从业务视角出发，根据限界的上下文边界划分业务领域边界，定义领域模型，确定业务边界，DDD领域模型可以清晰的划分微服务的逻辑边界和物理边界，是中台建设的核心理念和设计思想。

---
## 企业中台能力框架
中台是企业级能力复用平台
1. **业务中台**
+ 概述
	+ 业务中台的主要的建设目标：“将可复用的业务能力沉淀到业务中台，实现企业级业务能力复用和各个业务板块之间的联通和协同，确保关键业务链路的稳定和高效”,例如可以用户管理、订单管理、商品管理、支付等通用的能力，通过业务领域边界的划分和领域建模，沉淀到用户中心、订单中心、商品中心、支付中心等业务中台然后基于分布式微服务技术体系完成微服务建设
	+ 在业务建模上可以采用DDD方法，通过划分业务界限上下文编辑，构建中台领域模型，根据领域模型完成微服务拆分和设计
2. **数据中台**
+ 概述
	+ 数据中台中的大部分数据来源于业务中台，经过数据建模和数据分析等操作后，将加工后的数据返回业务中台为前台应用提供数据服务，或直接以数据类应用的方式面向前台应用提供API数据服务
	+ 数据中台一般包括数据采集、数据集成、数据治理、数据应用、数据资产管理，数据指标和指标体系建设，以及数据仓库或大数据等技术应用
3. **技术中台**
+ 概述
	+ API网关，微服务开发框架、微服务治理组件、分布式数据库以及分布式架构下的复制、同步等数据处理相关的关键技术组件
	1. API网关：主要包括，鉴权、降级限流、流量分析、负载均衡、服务路由、访问日志
	2. 微服务的治理：针对微服务的运行状态采取动态的治理策略，如服务注册、发现，限流、熔断和降级
	3. 分布式数据库：事务分布式数据库(OLTP)，分析型数据库(OLAP)、事务分析型数据库（HTAP）
	4. 数据处理组件：分布式缓存、搜索引擎、数据复制、消息中间件、分布式事务

## DDD 战略设计和战术设计
>战略设计中台，战术设计微服务
1. 战略设计是从业务视角出发，划分业务的领域边界，建立基于通用语言和业务上下文语义边界的限界上下文，构建领域模型。限界上下文可以作为微服务拆分和设计的边界
2.战术设计是从技术角度出发，对领域模型的实现，按照领域模型完成微服务的开发和落地

## DDD、中台和微服务之间的关系
如果将所有的业务看做为一个领域，在进行领域细分时可分为核心子域、通用子域、和支撑子域，从中台的业务视角来看，业务中台可分为通用中台和通用中台

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/wechat_20221005114555.jpg)

### 构建领域模型和划分微服务的边界
1. 事件风暴中根据场景分析，梳理业务过程中的用户操作、领域事件以及外部的依赖关系，找出业务对象产生的操作和行为，根据业务对象梳理出实体等领域对象
2. 根据领域实体之间的关联性，找出聚合根，将业务紧密相关的实体组合成聚合，确定聚合、聚合根、实体、值对象
3. 根据业务语义环境及上下文边界，将一个或多个聚合划分在一个限界上下文内，构建领域模型

## DDD的基本原理
知识体系：领域、子域、核心子域、通用子域、支撑子域、限界的上下文、实体、值对象、聚合、聚合根、领域事件、领域服务、应用服务、分层架构

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/v2-ed5c748f61b62d4dfc7d2ac199e6a18e_r.jpg)


## 限界的上下文：定义领域的边界

业务领域的边界是通过限界的上下文划分的，保护领域建模的完整性。

通用语言定义上下文对象的含义，限界上下文定义领域的边界。

限界上下文是在限定的的上下文件环内，用来封装通用语言和领域对象，保证领域内的一些术语、领域对象的确切含义，定义了领域模型的边界和业务的适用范围。

**限界上下文是确定微服务拆分和设计边界，是微服务拆分的主要依据，一个限界上下文理论上就可以拆分为一个微服务**

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/426bb5bfd40241bf9993ac9089e0cd33.png)


>[!Warning]
>限界上文基本概念上的独立性，一个限界的上下文内的子概念解释目的不应该超出上下文的边界，若出现以下的依赖关系需要思考是否有未澄清的问题
>1. **双向依赖：** 上下文之间缺少一个未被澄清的上下文，或者两个上下文其实可以合并为一个。
>2. **循环依赖：** 任何一个上下文发生变更，依赖链条上的上下文均需要需要变更
>3. **过长的依赖：** 自身依赖的信心不能直接从依赖者获取到，需要通过依赖者从其他依赖的上下文获取并传递，依赖链条上的任何一个上下文发生变更，其链后的任何一个上下文均需要变更。

## 实体和值对象：领域模型的基本单元

### 实体

>实体拥有唯一的标识符，并且标识符在经历状态变更后仍能保持一致

#### 1\. 实体的业务形态
实体是业务形态的业务对象，集多个业务属性、业务操作或行为于一体，将依存度高和业务关联紧密的多个实体对象和值对象进行聚合形成 **聚合**
#### 2\.实体的代码形态
实体表现为实体类，包含实体的属性和方法，这些方法可以实现实体的业务行为和业务逻辑
#### 3\. 实体的运行形态
实体以领域对象(DO)的形式存在，每个实体对象都有唯一的ID
#### 4\. 实体的数据库形态
一个实体可能对应0，1，多个数据库持久对象。有些实体可能只暂存一个运行态实体，不需要持久化（计算商品的价格）
#### 实体的特点
有ID标识，通过ID判断相等性，ID在聚合内是唯一的。实体与持久化对象不一定是一对一，例如权限实体 是由用户和角色两个持久化对象生成的，或者多个实体对应一个持久化对象。也有可能两个实体是从一个持久化对象中生成的。

### 值对象
>值对象是通过对象属性值来表示对象，他将多个相关属性组合为一个整体的概念，并且没有唯一的标识符，用于描述目的、具有整体和不可改变的属性。

#### 1. 值对象的业务形态
源于实践风暴所构成的领域模型，包含若干个属性，与实体构成聚合

#### 2. 值对象的代码形态
- 如果值对象是单一属性可直接定义为实体类的属性
- 如果值对象是属性集合，则可以设计为值对象类，将具有整体概念的多个属性归属到属性集合，值对象没有ID被实体整体引用

#### 3. 值对象的数据库形态
值对象采用的非数据库范式，值对象的属性值和引用他的实体对象一般保存在同一个数据库实体表

#### 4. 值对象的优势和局限
优势：简化了数据库设计减少了实体表的数量，可以简单清晰表达业务概念。值对象的不可变性，确保了值对象永远都是正确的，在并发环境下不会被意外修改，可同时被多个实体引用，可以实现重用和共享
局限：无法基于对象快速查询和统计分析。如果实体引用 的值对象太多则会在实体堆积一些缺乏概念完整性的属性

#### 值对象的特点
值对象无ID，数据不可变，没有生命周期，用完就扔。值对象通过属性判断相等性。

### 实体和值对象的关系
一些值对象可能来源于其他聚合，以数据冗余的方式完成不同领域中数据流转和共享。在值对象的数据源头聚合，以实体或者聚合根的形式存在，完成实体和数据的集中维护。而在自己聚合里以值对象的形式存在，被聚合内的某一实体引用。例如：订单聚合中订单实体的收货地址值对象是从用户中心聚合中地址值对象中获取生成的。
也可采用ID单一属性值对象的方式关联，这种方式可能导致频繁跨聚合查询，增加微服务之间的耦合度

实体和值对象简单变更不会让领域模型和微服务发生太大的变化

## 聚合和聚合根

### 聚合
**聚合内有一个聚合根、多个实值对象和领域服务等领域对象**。聚合是拆分微服务的最小业务单元，一个微服务中可能包含多个聚合。微服务在演进过程中，聚合的重组或拆分会引起领域模型和微服务的变化，聚合作为组合和拆分的基本单位，降低后期代码搬迁过程，只需要将聚合的代码整体搬迁。

聚合的业务逻辑是由聚合根、实体和值对象、领域服务实现的。聚合内的数据修改必须由聚合根统一组织，确保每次数据的修改都是按照聚合内的统一业务规则来完成，通过*高内聚低耦合和单一职责*定义聚合内部的实体和值对象。聚合内的实体通过充血模型实现自身的业务逻辑。跨多个实的领域逻辑通过领域服务来实现。跨多个聚合业务逻辑组合编排通过上层的应用服务来实现。
**聚合的特点**：聚合内部逻辑高内聚，聚合之间低耦合，聚合是领域模型中最小的业务逻辑单元。

### 聚合根
聚合根的主要目的是避免聚合内由于复杂数据模型缺少统一的业务规则控制，而导致聚合内实体和值对象等领域对象之间数据不一致性的问题。

#### 聚合根的职能
避免聚合内由复杂的数据模型缺少统一的业务规则控制，导致聚合内数据的不一致性
- 聚合根是实体，拥有实体的业务属性和业务行为，可以实现自身的业务逻辑
- 聚合的管理者，在聚合内对实体和值对象通过对象引用的方式进行组织和协调，协同完成聚合内共同的业务逻辑
- 聚合对外的联络人和接口人，聚合之间通过聚合根ID关联方式接受聚合外部任务和请求，在界限上下文内实现聚合之间的业务协作。聚合外部不能通过对象引用方式访问聚合内的对象（当访问其他聚合实体时，先通过聚合根ID访问聚合根再导航到聚合内部的实体）

#### 聚合根特点
聚合根是实体，拥有全局唯一标识符，有独立的生命周期管理了聚合内所有的实体和值对象的生命周期，可以通过聚合根获取聚合内所有的实体和值对象，一个聚合中只有一个聚合根

聚合根和领域服务都可完成跨多个实体的业务逻辑。聚合根应作为实体实现与聚合根自身行为相关的业务逻辑，跨多个实体的复杂领域逻辑放在领域服务中实现

### 聚合的设计
1. 采用事件风暴梳理所有业务行为，找出所有的值对象和实体
2. 从众多实体中找出适合作为聚合对象管理者的根实体
3. 根据业务单一职责和高内聚原则，找出与聚合根相关联紧密的实体和值对象，构建出聚合
4. 在聚合内根据聚合根、实体、值对象的依赖关系找出引用和依赖关系

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/wechat_20221005194346.jpg)


### 聚合的设计原则
- **在一致性边界内建模真正不变的条件。** 聚合时用来封装真正的业务不变性，不是简单的将对象组合在一起。聚合内有一套不变的业务规则，实体和值对象按照统一的规则运行，保证聚合内对象数据的一致性。比如订单聚合的业务规则订单总金额等于所有商品的明细金额之和
- **设计小聚合。** 如果聚合设计的过大，聚合会因为包含太多的实体和值对象导致实体之间的管理，领域逻辑实现过于复杂
- **通过唯一标识引用其他聚合。** 聚合之间通过引用聚合根ID方式，而不是对象引用。避免导致聚合内的边界不清晰，
- **在边界之外使用最终一致性。** *聚合内采用数据强一致性，在聚合之间采用最终一致性*。在DDD中强调一个事务只能修改一个聚合内的数据。如果涉及多个聚合应采用领域事件驱动机制
- **通过应用层实现跨聚合的服务调用。**

#### 聚合的设计模式
##### 仓储模式
仓储模式是用来隔离业务实现逻辑与基础层资源实现逻辑，降低他们之间的耦合。

仓储模式包含储接口和仓储实现。仓储接口面向领域层提供基础层数据相关处理的访问接口，仓储实现完成仓储接口对应的数据持久化逻辑处理。

仓储设计的重要原则，一个聚合只能有一个仓储。

##### 工厂模式
在创建DO对象时，需要保证据换根和他依赖的对象示例同时被创建
- DO对象构建和数据初始化时，通过仓储先从数据库中获取PO对象，通过工厂完成DO对象的构建和数据初始化
- DO对象持久化时，通过工厂完成DO到PO对象的数据转换，完成仓储数据持久化

## 领域事件
领域事件采用事件驱动架构（EDA）设计，可以切断领域模型之间的强依赖关系，在领域事件发布后，事件发布方不必关心*订阅方事件是否处理成功*。一般采用消息中间件和事件发布订阅的异步处理方式，实现数据最终的一致性。

#### 微服务内的领域事件（事件总线）
在微服务内发生的领域事件，如果同时更新多个聚合数据时，需要确保多个聚合数据的一致性。按照DDD**一个事务只更新一个聚合** 可以引入事件总线（Event Bus）通过事件总线实现微服务内的多聚合数据的最终一致性。也可以采用事务机制保证数据的强一致性。

#### 微服务之间的领域事件（消息队列）
跨微服务之间的领域事件可以在不同的界限上下文，或领域模型之间实现业务协作，主要目的是实现业务解耦，减轻服务之间同步访问的压力，优先采用基于消息中间件的最终一致性，也可采用分布式事务机制实现强一致性。

### 领域事件驱动实现机制

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/wechat_20221005162921.jpg)


#### 1. 事件的构建和发布
**事件发布可以在应用服务和领域服务中完成**

事件实体的基本属性：唯一标识的id、发生事件、事件类型、事件源、业务属性。唯一标识id能够在多个界限上下文之间传递，也可以避免事件消息的重复消费。业务属性记录与事件发生那一刻领域事件的业务数据，领域事件发生后事件实体内的业务数据不可以再更改，只能产生新的领域事件。在领域事件发布之前需将领域事件实体持久化到数据库表中

#### 2. 事件数据的持久化
- 持久化到本地业务数据库的事件表中。利用本地事务保证业务和事件数据的一致性
- 持久化到共享事件数据库中。业务数据和事件数据可能不在一个数据库中，持久化式会跨数据库，需要分布式事务机制保证数据的强一致性

#### 3. 事件总线
事件总线式进程内模式，在微服务内聚合之间遍历订阅者

事件流程：

	 1. 微服务内的订阅者，直接分发到指定的订阅者
	 2. 微服务外的订阅者，先将事件数据保存到事件表中然后异步发送到消息中间件， 如果同时在微服务内和微服务外的订阅者，先分发到内部订阅者，将事件数据保存到事件表中，再异步发送到信息中间件

#### 4. 消息中间件
用于跨微服务的事件发布订阅，源端数据发布时需要持久化事件表记录事件基本数据以及事件推送和处理状态，还有消息补偿机制在订阅者出现故障可完成数据重放

消息的发布机制：
- 应用逻辑推送
- CDC获取事件增量数据

##### 5. 事件的接收和处理
订阅者微服务通过事件唯一标识ID避免对事件数据重复消费，在完成业务处理后修改事件的状态数据，也可将事件处理结果通过反馈队列反馈给发布者微服务

## DDD分层架构

### DDD分层架构设计
![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20221005100905.jpg)

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/uTools_1664936069700.png)


![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20201224104242610.png)


#### 1. 用户接口层

提供用户、程序、自动化测试、皮处理脚本负责向用户显示信息，解释用户指令。**主要完成后端微服务与前端不同用户的接口和数据的适配**

在面向不同的前端时，同一段业务逻辑在不同的渠道下可能前端展示的页面要素不同，因此要求后端返回的数据结果不同，可能需要为前端应用提供不同的服务适配但会造成大量的重复代码。这时用户接口层的`facade`服务封装应用服务，适配不同类型的服务接口，数据组装`Assembler`服务可以根据不同的前端应用要求完成前端DTO和后端DO的组装、转换操作

#### 2. 应用层
**应用层的服务包括应用服务、领域事件发布和订阅**

应用服务可对微服务内的领域服务以及对微服务外的应用服务进行组合、编排和转发，处理业务用例的执行顺序机结果的拼装，在应用服务中还可进行安全认证、权限校验、事务控制、领域事件的发布和订阅。

应用层是很薄的一层，主要面向用户用例操作，协调和指挥领域对象来完成业务逻辑。应用层还是与其他系统的应用层进行交互的必要渠道，是微服务之间的服务通道，微服务在应用层可以调用其他微服务的应用服务，完成微服务之间的服务组合编排。

在微服务内应用服务可以直接调用仓储服务。这种方式主要针对类似缓存或文件的基础数据访问，或者设计多表关联复杂数据查询操作，由于没有太多的业务规则的领域逻辑可以绕过领域层。

在微服务之间的调用，微服务中的应用服务可以通过API网关访问其他服务中的应用服务。

>[!Attention]
>应用层的主要职能是服务的组合和编排，不要将领域层的核心领域逻辑在应用层中实现，会使得领域模型失焦，导致应用层和领域层的边界混乱

#### 3. 领域层
领域层主要实现领域模型的核心业务代码，体现领域模型的业务能力。**领域层用于表达业务概念、业务状态和业务规则** 
领域层主要关注实现领域对象或者聚合自身的原子业务逻辑，不太关注用户的操作或者流程方面的业务逻辑。**主要体现领域模型的能力**

**领域模型的业务逻辑主要是由实体和领域服务实现**。实体会采用充血模型实现与之相关的业务，当单一实体（值对象）不能实现时，这时需要领域服务来组合协调的聚合内的多个实体完成负复杂的业务逻辑。

为隐藏领域层的业务逻辑实现，所有领域方法和服务等均须通过领域服务对外暴露。

为实现微服务内聚合之间的解耦，原则上禁止跨聚合的领域服务调用和跨聚合的数据相互关联。跨多个聚合业务逻辑组合编排通过上层的应用服务来实现。

领域层可以是数据权限验证层，用户对象的权限，本质上有也是业务规则，且业务中可能存在隐藏的规则，隐藏的业务规则可以通过在DDD中使用Specification 模式来实现。
>[!Attention]
>实体对象和领域服务在实现业务逻辑上不是同一级别的，如果单一实体自身的业务行为也由领域服务来完成，会造成贫血模型。
>
>不要把与领域无关的领域模型放在领域层实现，以保证领域层的纯洁和领域模型的稳定

#### 4. 基础层
基础层贯穿了DDD所有层，主要职能为其他各层提供通用的技术和基础服务包括第三方工具、驱动、消息中间件、网关、文件、缓存、数据库等

基础层主要由仓储服务的逻辑代码，仓储采用依赖倒置设计，封装基础资源服务的实现，实现应用层、领域层与基础层的解耦

### DDD分层架构的原则
**每层只能与位于其下方发生耦合** 这句话还没有理解

**严格分层：** 任何层只能与其直接下方的层产生耦合

**松散分层：** 允许某层与其任意下方的层发生依赖

### DDD分层架构的优势
- 层间松耦合
- 使程序结构更加清晰方便升级和维护

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/wechat_20221029154235.jpg)


## 服务和数据在微服务各层的协作


### 补充 VO、DTO、DO、PO的概念
**VO（View Object）**： 视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。

**DTO（Data Transfer Object）**： 数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。

**DO（Domain Object）**： 领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。

**PO（Persistent Object）**： 持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。

微服务各层数据对象的职责和转换过程

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/20201224103115413.png)


## 中台和微服务的设计
### 中台建设
中台建模时，会对业务和应用的逻辑边界（聚合）和物理边界（微服务）进行划分，这种划分考虑了未来微服务架构演进和以聚合为单位的功能重组

**领域模型建设的参考：**
- 领域模型核心业务逻辑聚焦在核心原子业务逻辑，职责单一，可自由组合出新的复杂服务
- 领域模型高度聚焦核心领域逻辑，代码位于最核心的领域层
- 领域模型业务的高内聚和职责单一特性，有利于数据内聚和数据质量的提升
- 领域模型的高内聚，低耦合的聚合边界和解耦策略，有利于提升微服务架构的演进
- 合理的架构分层和职责分工，可降低外部需求的变化对核心业务逻辑的影响

### 微服务项目的建设
#### 1. 项目级微服务
微服务之间的集成复杂度相对较小，微服务之间的服务组合和编排，可以在某个关键微服务的应用层，通过应用服务的组合和编排完成。微服务内的应用服务可以调用其他微服务的应用服务。
![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/wechat_20221113090240.jpg)


#### 2. 企业级微服务

企业及的业务流程需要的哥中台的微服务一起协作完成，在多个微服务上增加一层BFF层（服务于前端的后端），主要职能是处理跨中台微服务的服务组合和编排，实现微服务之间的服务和事务协作

BFF 微服务只有应用层和用户接口层的职能，适配不同前端和渠道的需求，为前端提供粗粒度的组合服务，BFF层没有领域模型，没有领域层
![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/wechat_20221005191218.jpg)


[标准化思想及组装式架构在后端BFF中的实践 - 美团技术团队 (meituan.com)](https://tech.meituan.com/2022/04/28/composable-architecture-in-bff-2022.html)

## 事件风暴构建领域模型
领域建模过程中需要关注，某些业务动作或行为（事件）是否触发下一个业务动作，这个动作（领域事件）的输入输出是什么？是谁（实体）发出的动作（命令），触发了这个动作（事件）

### 基于事件风暴的领域建模
领域建模的关键过程：产品愿景分析、场景分析、领域建模、微服拆分于设计等

#### 产品愿景分析
完成产品顶层价值设计和分析，项目在目标用户、核心价值、产品需要具备的核心竞争力方面达成一致

项目团队需要思考的问题：
1. 用户中台到底能够做什么？
2. 用户中台的业务范围、目标用户、核心价值和愿景是什么？与其他同类产品的核心优势在那里？

#### 场景分析
从用户的操作角度出发，根据用户流程或业务流程，采用用例和场景分析发方法，探索领域中的典型场景，找出领域事件、实体和命令等领域对象，支撑领域建模的过程。

#### 领域建模
1. **提取领域对象**：从命令和领域事件中提取产生这些业务行为的业务对象及实体
2. **构建聚合**：从实体中分析出聚合根，找出聚合根引用的实体和值对象，构建聚合
3. **划定限界的上下文：** 根据业务上下文语义环境，将聚合归类，划定业务领域所在的限界上下文边界
4. **建立领域模型上下文服务地图**：分析截断领域模型之间可能存在的循环依赖关系，限界上下文之间的服务关联应该是右向无环网状依赖关系，避免微服务出现服务循环调用

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221006134022.jpg)
![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221006134220.jpg)


## DDD拆分问题

### DDD垂直拆分联表查询问题

#### 1.使用实时查询
例如
>订单列表上有实时的物流信息，物流信息由物流服务提供，并且变化频繁。业务要求用户能看到自己的订单列表，列表中有一列为物流信息，包括：物流状态、物流单号、物流公司。

在应用层将订单分页后通ID异步查询物流服务，将数据聚合到一起，这种调用方式也需要进行熔断和回退，当关联服务不可用时，依然可以将可用的数据返回

#### 2.使用数据副本冗余和反范式

常见的业务场景
>1. 某电商系统将订单和商品拆分为不同的服务，但是业务要求订单列表中需要显示商品名称，收货地址，票据等。 
>2. 某大型网站提供了用户认证 SSO 服务，且拆分了单独的用户服，在某管理后台应用中，需要显示已经登录的用户列表和用户基本信息。  
>3. 某电商系统将订单和支付拆分为不同的服务，但是业务要求订单列表中需要显示支付状态。

场景1：  可以使用DDD的值对象来设计冗余关联的数据，利用值对象的不可变性，让代码更直观

场景2：在认证这个上下文中，模型的本质是认证后的用户而非用户本身。因此往往是 token + 用户快照，不过并不是持久化到数据库中（ redis ），所以在线用户列表并不需要去关联用户表，数据的一致性在用户重新登录后完成。

场景3：在订单中冗余支付状态信息，但这种需要服务间更新冗余数据，可以利用数据的最终一致性完成。不需要实时访问支付服务，而是采用发布订阅的方式将支付状态的数据同步到订单服务

>[!Attention]
>1. 盲目冗余，被冗余数据和当前服务完全没有关系的，不要冗余。
>2. 对数据更新十分频繁的，对业务上延迟要求接受度低的不要设计为冗余

#### 3.使用搜索引擎解决复杂查询
场景
>一个社区应用，用户发帖时间达到一定可以领取荣誉勋章，该系统将用户信息和成长体系分为两个服务。现在有一个需求是管理员需要根据荣誉勋章或者用户名进行搜索，并显示到一个列表上。同时类似业务也有可能出现在用户侧。

这个场景有两个特点。第一，不满足冗余设计的条件，荣誉勋章输入成长体系的一部分，这个服务和用户服务不太搭边。第二，需要跨服务搜索，且搜索会很复杂

通过使用 Elastic Search 创建多个索引，解决各种不同的查询需求。搜索引擎应该只拿来做搜索，不应该获取搜索引擎中的数据直接应用于交易业务。如用户从搜索引擎获取的列表，然后根据该条目操作退款等业务。即使条目中含有相关数据，也应根据关联字段实时访问服务获取最新真实数据，保证强一致性。

### DDD垂直拆分分布式授权问题

#### DDD与OAuth2匹配

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/v2-91c8590f7b1903338305f4843a4f9baf_720w.jpg)


通过 DDD 和 OAuth2 的结合，可以清晰地将 DDD 中的各种角色映射到 DDD 分层模型上。总结如下：

-   DDD 各种应用服务，需要实现为 OAuth 客户端。
-   DDD 各种领域服务一般设计为资源服务器。
-   授权服务器需要既要提供一个 DDD 概念上的应用层和领域层，可以部署到一起发布。
-   用户服务既要充当授权服务的资源提供者，实现用户登录。又要充当资源服务器，需要被权限管理。是一个比较特殊的互为依赖的关系，为了破解这个死循环，所以往往系统管理员都内置在数据库中。
-   系统内部一般使用密码模式简化授权流程。
-   如果需要提供一个开放的授权服务，授权服务器需要支持授权码模式。
-   服务之间的信任问题使用客户端模式，通过 AK/SK 访问，在很多公司内部叫做 ”集成账号“ 调用。
-   主流的实现上一般设计了认证服务和用户服务。用户服务负责用户、权限、部门等数据管理，认证服务负责 token 的分发，权限校验，绑定第三方登录等职责。


#### 权限设计的经验
-   通过 HTTP 请求的方法来设计拦截器，因为很多权限不是以 HTTP 请求为粒度设计的。另外权限应该同应用层和领域层有关，接入层只起数据编解码、转换的作用，拦截器不要放到接入层。
-   权限设计过于复杂，例如用户对一个集合部分数据有权限，部分无权限。业务往往要求 ”无权限即不可见“。但是这样做成本非常高，如果设计成上面方案 1 之后几乎没有能力扭转局面。这种场景会带来分页、过滤、统计等各种问题，建议从业务上避免。
-   通过 HTTP header 传递权限信息。服务之间的权限信息不要侵入业务方法，与之类似的还有语言、版本、trace id 之类的信息。
-   用户密码错误，不要提示密码错误，应该提示”用户名或密码错误“。防止用户名被嗅探，被账户注册机等灰产盯上。

参考文章：
- [DDD 指导应用垂直拆分的分布式授权问题 - 知乎](https://zhuanlan.zhihu.com/p/141468688)

### DDD处理多表关联业务处理

多对多就是对客体的含混不清，迷失了中间模型
```text
认识论中主体是由认识能力和实践能力的人或者是在社会实践中认识世界改造世界的人，客体的实践和认识活动所指的对象，存在于主体之外的客观事物。在业务系统中，可以把 Controller、Service 这类带有行为能力的对象看做拟人化的主体，而 Entity、Model 看做客体。
```

**例如：**
用户可以处于不同的空间，在不同的空间中可以访问空间中的资源。一个空间可以拥有多个用户，用户可以出现在多个空间中

将空间和用户的关系被拆解为 “空间拥有多个成员” 和 “成员可以引用用户” 两个关系，转换为一对多。

### DDD写代码是否会导致过度设计
通过领域专家对业务的描述来建立领域模型，团队中所有的人都要理解并且认可，可能有的业务不复杂或者技术要求比较高，对性能和并发要求高业务不复杂，更可能不需要领域专家的参与，它的出现主要解决系统复杂的业务系统分析和设计。并不是为了解决所有的代码结构设计的问题。主要实现业务与代码一致，业务的改动幅度与代码的改动一致。

### JPA与Mybatis 那个更适合领域开发
因为DDD强调领域模型的设计和实现，JPA提供了更好的面向对象的持久化支持，可以直接将领域模型映射到数据库表，减少了开发者的工作量。此外，JPA提供了标准化的API和查询语言，可以更好地支持领域模型的查询和操作。mp更多的使用方向还是以表设计为重，
更适合于对性能要求较高、需要进行复杂查询和关联查询的场景。MyBatis Plus可以直接编写原生SQL语句，对数据库的操作更加灵活，可以更好地满足复杂业务需求。
总结来说，如果注重领域模型的设计和实现，且对查询和操作的灵活性要求不高，使用JPA更合适；如果对性能要求较高，且需要进行复杂查询和关联查询，使用MyBatis Plus更合适。如果非要用MP也不是不行，我们提供了一个dao层接口，实现即可，不关心底层ORM和数据库的选型。

## 参考文章
- [DDD 概念参考 (domain-driven-design.org)](https://domain-driven-design.org/zh/ddd-concept-reference.html)
- [标准化思想及组装式架构在后端BFF中的实践 - 美团技术团队 (meituan.com)](https://tech.meituan.com/2022/04/28/composable-architecture-in-bff-2022.html)
- [后台开发进阶：白话DDD从入门到实践 (qq.com)](https://mp.weixin.qq.com/s/_qi3pE-uF8w3uHK0oinrcA)
- [降低复杂度提升效率，DDD在携程用车/租车订单系统重构中的实践 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/620103914)