## 缓存设计


### 如何应用缓存
缓存适用于各种各样的使用案例，但要充分利用缓存，需要进行一定的规划。在决定是否缓存一段数据时，请考虑以下问题：

-   使用缓存值是否安全？ 同一段数据在不同的上下文中可能具有不同的一致性要求。例如，在线结账期间，您需要物品的确切价格，因此不适合使用缓存。但在其他页面上，价格晚几分钟更新不会给用户带来负面影响。
-   对于该数据而言，缓存是否是高效的？ 某些应用程序会生成不适合缓存的访问模式；例如，扫描频繁变化的大型数据集的键空间。在这种情况下，保持缓存更新可能会抵消缓存带来的所有优势。
-   数据结构是否适合缓存？ 简单地缓存数据库记录通常足以提供显著的性能优势。但在其他一些时候，数据最好以多条记录组合在一起的格式进行缓存。缓存以简单的键值形式存储，因此您可能还需要以多种不同格式缓存数据记录，以便按记录中的不同属性进行访问。

## 缓存设计模式

### 惰性缓存
惰性缓存（也称作惰性填充、预留缓存、直读缓存）是常见的缓存模式。其基本思想是仅在应用程序实际请求对象时才填充缓存。适合“经常读取但很少写入数据的模式”。应用流程：
1.  应用程序收到数据查询，例如头 10 条最新的新闻报道。
2.  应用程序检查缓存，查看对象是否在缓存中。
3.  如果是 (缓存命中)，则返回缓存的对象，调用流程结束。
4.  如果不是 (缓存未命中)，则从数据库查询对象。填充缓存，返回对象。

![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/uTools_1668072252050.png)

与其他方法相比，这种方法具有以下几个优势：

-   缓存仅包含应用程序实际请求的对象，有助于使缓存大小维持在可管理范围内。新对象仅在需要时添加至缓存。这样，当缓存满时，您可以让所用的引擎移出最少访问的键 (引擎默认行为)，从而被动地管理缓存内存。
-   新缓存节点上线 (例如应用程序扩展时) 时，惰性填充方法会在应用程序首次请求对象时将这些对象自动添加至新缓存节点。
-   缓存过期很容易处理：只需删除缓存的对象，下次请求新对象时，从数据库获取对象。

### 直写缓存

在直写缓存中，缓存在数据库更新时实时更新
![](https://zhaosi-1253759587.cos.ap-nanjing.myqcloud.com/files/obsidian/picture/uTools_1668073130560.png)
与惰性缓存相比优势：
-   它避免了缓存未命中，可帮助应用程序更好、更快捷地运行。
-   它将一切应用程序延迟转移到用户更新数据，更符合用户预期。相比之下，一系列缓存未命中会给用户留下应用程序运行缓慢的印象。
-   它简化了缓存过期。缓存始终是最新的。

缺点：
-   可能会向缓存中填充一些实际上访问不到的多余对象。这不仅占用了额外的内存，而且未用到的项目还可能将更有用的项目“驱逐”出缓存。
-   如果某些记录反复更新，可能导致大量缓存改动。
-   缓存节点出现故障时，缓存中的这些对象都将丢失。您需要通过某种方法 (例如惰性填充) 将缺失对象重新填充至缓存。

### 旁路缓存

**写策略的步骤：**
-   先更新数据库中的数据，再删除缓存中的数据。

**读策略的步骤：**
-   如果读取的数据命中了缓存，则直接返回数据；
-   如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户

为什么在更新缓存的时候时删除缓存而不是更新缓存？

因为更新的值可能是hash、list等类型，更新其中某个元素就需要遍历，消耗时间和资源。在要使用更新的数据的时候才更新缓存，这是懒加载。

**高并发脏读的三种情况**

-   **先更新数据库，再更新缓存**

在更新数据库时，如果在update和commit之间有新的读操作，此时更新了缓存中的数据，但是在执行commit命令的时候失败了，数据库中就还是旧数据，而缓存中是新数据，数据不一致。

-   **先删除缓存，再更新数据库**

在更新数据库时，如果在update和commit之间有新的读操作，此时缓存中的数据已经被删除，就会将数据库中的旧数据读到缓存中并保存下来，再返回给客户端，然后commit执行了，数据库中的数据更新了。此时缓存中的数据与数据库中的数据就不一致了。

-   **先更新数据库，再删除缓存**

在更新数据库时，如果在update和commit之间有新的读操作，此时缓存中没有数据，就会将数据库中的旧数据读到缓存中并保存下来，再返回给客户端，然后commit执行了，数据库中的数据更新了。此时缓存中的数据与数据库中的数据就不一致了。为了解决这个问题，可以采用延时双删策略。就是在commit命令执行后的2秒内，再次将缓存中对应着之前在数据库中更新的数据，在缓存中依然是旧数据，删除掉。

**Cache Aside 策略适合读多写少的场景，不适合写多的场景**，因为当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。如果业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：

- 一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；

- 另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受。

### Read/Write Through（读穿 / 写穿）策略（直读/直写）
Read/Write Through（读穿 / 写穿）策略原则是应用程序只和缓存交互，不再和数据库交互，而是由缓存和数据库交互，相当于更新数据库的操作由缓存自己代理了。应用程序只操作缓存，缓存操作数据库。

### Read Through 策略
先查询缓存中数据是否存在，如果存在则直接返回，如果不存在，则由缓存组件负责从数据库查询数据，并将结果写入到缓存组件，最后缓存组件将数据返回给应用。

### Write Through 策略
当有数据更新的时候，先查询要写入的数据在缓存中是否已经存在：

如果缓存中数据已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，然后缓存组件告知应用程序更新完成。
如果缓存中数据不存在，直接更新数据库，然后返回；

## 缓存生存时间

缓存过期可能会在短时间内演变成极其复杂的问题。在之前的示例中，我们只对单一用户记录进行操作。而在实际应用程序中，给定页面或屏幕通常会同时缓存大量不同的内容 - 个人资料数据、热门新闻报道、建议、评论等等，所有这些内容以不同方式进行更新。

-   始终向所有缓存键应用生存时间 (TTL) - 以直写缓存方式更新的缓存键除外。您可以将生存时间指定为很长的时间，例如数小时，甚至数天。这种方法能够捕获应用程序错误，例如在更新底层记录时，您忘记更新或删除给定的缓存键。最终，缓存键会自动过期并刷新。
-   对于频繁更改的数据，例如评论、排行榜、活动流等，不要添加直写缓存或复杂的过期逻辑，只需设置较短的 TTL (几秒钟) 即可。如果某条数据库查询在生产环境中被大量访问，您只需改动几行代码就能为此查询添加 TTL 为 5 秒的缓存键。此代码可谓是一种美妙的“创可贴”，能够在您评估更优雅的解决方案时让您的应用程序保持正常运行。
-   Ruby on Rails 团队研究出了一种更新的模式 - 俄罗斯套娃缓存。在这种模式下，嵌套记录通过其自有缓存键进行管理，顶层资源就是这些缓存键的集合。假设您有一个包含用户、文章和评论的新闻网页。在这种方法中，他们中的每个都是自己的缓存键，页面则分别查询每个键。

## 驱逐策略

[Key eviction | Redis](https://redis.io/docs/reference/eviction/)

当内存满溢或超出缓存中的 maxmemory 设置时，就会发生移出，导致引擎选择要移出的键以管理其内存。键的选择基于所选的移出策略。

移出策略概述如下：

allkeys-lfu：无论 TTL 设置如何，缓存都会移出最不常用的 (LFU) 键  
allkeys-lru：无论 TTL 设置如何，缓存都会移出最近最少使用的 (LRU) 键  
volatile-lfu：缓存从设置了 TTL 的缓存中移出最不常用的 (LFU) 键  
volatile-lru：缓存从设置了 TTL 的缓存中移出最近最少使用的 (LRU) 键  
volatile-ttl：缓存移出具有最短 TTL 设置的键  
volatile-random：缓存随机移出具有 TTL 设置的键  
allkeys-random：无论 TTL 设置如何，缓存都会随机移出键  
no-eviction：缓存不移出任何键。这将阻止后续写入，直到内存释放。